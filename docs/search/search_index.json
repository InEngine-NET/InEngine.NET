{
    "docs": [
        {
            "location": "/", 
            "text": "InEngine.NET allows commands to be queued, scheduled, and run directly. \n\n\nGet started by reading up on \ncommands\n, then \nscheduling\n and \nqueuing\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/commands/", 
            "text": "Commands\n\n\nCommands are the fundamental abstraction used to run custom logic.\n\n\nCreate a Command\n\n\nThe InEngine.Core package is required. Install it into your own Visual Studio project.\n\n\nPackage Manager\n\n\nInstall-Package InEngine.Core\n\n\n\n\n\nNuget CLI\n\n\nnuget install InEgine.Core\n\n\n\n\n\n.NET CLI\n\n\ndotnet add package InEngine.Core\n\n\n\n\n\nPaket CLI\n\n\npaket add InEngine.Core\n\n\n\n\n\nAdding a class that implements \nInEngine.Core.ICommand\n is the simplest way to create a command.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nICommand\n\n    \n{\n\n        \npublic\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \nConsole\n.\nWriteLine\n(\nHello, world!\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nA command that implements ICommand can be run directly or \nqueued\n, but it cannot be \nscheduled\n.\nExtending the \nInEngine.Core.AbstractCommand\n class adds extra functionality, like a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nAbstractCommand\n\n    \n{\n\n        \npublic\n \noverride\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \nConsole\n.\nWriteLine\n(\nHello, world!\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRun a Command\n\n\nCreate a class that implements \nInEngine.Core.IOptions\n in the same assembly as the command class.\nAdd a VerbOptions attribute, from the CommandLine namespace, that defines the name of the command. \nOptional help text can also be specified in the VerbOption attribute.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method if desired.\n\n\nusing\n \nCommandLine\n;\n\n\nusing\n \nCommandLine.Text\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyOptions\n \n:\n \nIOptions\n\n    \n{\n\n\n        [VerbOption(\nmy-command\n, HelpText=\nMy example command.\n)]\n\n        \npublic\n \nMyCommand\n \nMyCommand\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n\n        [HelpVerbOption]\n\n        \npublic\n \nstring\n \nGetUsage\n(\nstring\n \nverb\n)\n\n        \n{\n\n            \nreturn\n \nHelpText\n.\nAutoBuild\n(\nthis\n,\n \nverb\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDownload the InEngine binary distribution, from the \nGitHub Releases\n page, that matches the version of the InEngine.Core package you included.\n\n\nCopy your project's DLLs into the Plugins subdirectory included in the binary distribution. \nAdd your plugin to the \n\"Plugins\" list in appsettings.config\n at the root of the binary distribution.\n\n\nRun your command:\n\n\ninengine.exe -pMyCommandPlugin my-command\n\n\n\n\n\nExecuting Arbitrary Processes\n\n\nIt isn't necessary to create C# classes to utilize InEngine.NET.\nArbitrary commands can be run, with an argument list by leveraging the InEngine.Core plugin's \nproc\n command.\nThe command lists directory contents using \"ls\" with the \"-lhp\" switches:\n\n\ninengine.exe -pInEngine.Core proc -c\n/bin/ls\n -a\n-lhp\n\n\n\n\n\n\nView Available Plugins\n\n\nRun inengine.exe without any arguments to see a list of plugins:\n\n\n  ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | || \n_ \\|  _| | \n_ \\ / _` | | \n_ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nUsage:\nInEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  p, plugin           Plug-In to activate.\n\n  s, scheduler        Run the scheduler.\n\n  c, configuration    (Default: ./appsettings.json) The path to the \n                      configuration file.\n\n\nPlugins:\n  InEngine.Core\n\n\n\n\n\nView Commands in a Plugin\n\n\nRun inengine.exe with only the plugin specified:\n\n\ninengine.exe -pInEngine.Core\n\n\n\n\n\nThe \nInEngine.Core\n library is itself a plugin that contains queue-related and other commands. \nAs an example, this is the help output for the core plugin.\n\n\n  ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | || \n_ \\|  _| | \n_ \\ / _` | | \n_ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nPlugin: \n  Name:    InEngine.Core\n  Version: 3.x\n\n\nCommands:\n  queue:publish     Publish a command message to a queue.\n  queue:consume     Consume one or more command messages from the queue.\n  queue:length      Get the number of messages in the primary and secondary queues.\n  queue:flush       Clear the primary or secondary queues.\n  queue:republish   Republish failed messages to the queue.\n  queue:peek        Peek at messages in the primary or secondary queues.\n  echo              Echo some text to the console. Useful for end-to-end testing.\n  proc              Launch an arbitrary process.\n\n\n\n\n\nPrint Help Text for a Plugin's Commands\n\n\nRun the command with the -h or --help arguments.\n\n\ninengine.exe -pInEngine.Core queue:publish -h\n\n\n\n\n\nThe \nInEngine.Core\n plugin's command to clear the InEngine.NET queues produces this help message. \n\n\nInEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  --command-plugin    Required. The name of a command plugin file, e.g. \n                      InEngine.Core.dll\n\n  --command-verb      A plugin command verb, e.g. echo\n\n  --command-class     A command class name, e.g. \n                      InEngine.Core.Commands.AlwaysSucceed. Takes precedence \n                      over --command-verb if both are specified.\n\n  --args              An optional list of arguments to publish with the \n                      command.\n\n  --secondary         (Default: False) Publish the command to the secondary \n                      queue.\n\n\n\n\n\nWriting Output\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides some helper functions to output text to the console, for example:\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \nLine\n(\nDisplay some information\n);\n\n\n}\n\n\n\n\n\n\nAll of these commands append a newline to the end of the specified text:\n\n\nLine\n(\nThis is some text\n);\n                  \n// Text color is white\n\n\nInfo\n(\nSomething good happened\n);\n            \n// Text color is green\n\n\nWarning\n(\nSomething not so good happened\n);\n  \n// Text color is yellow\n\n\nError\n(\nSomething bad happened\n);\n            \n// Text color is red\n\n\n\n\n\n\nThese commands are similar, but they do not append a newline:\n\n\nText\n(\nThis is some text\n);\n                      \n// Text color is white\n\n\nInfoText\n(\nSomething good happened\n);\n            \n// Text color is green\n\n\nWarningText\n(\nSomething not so good happened\n);\n  \n// Text color is yellow\n\n\nErrorText\n(\nSomething bad happened\n);\n            \n// Text color is red\n\n\n\n\n\n\nYou can also display newlines:\n\n\nNewline\n();\n      \n// 1 newline\n\n\nNewline\n(\n5\n);\n     \n// 5 newlines\n\n\nNewline\n(\n10\n);\n    \n// 10 newlines\n\n\n\n\n\n\nThe methods can be chained together:\n\n\nInfoText\n(\nYou have this many things: \n)\n\n    \n.\nLine\n(\n23\n)\n\n    \n.\nNewLine\n(\n2\n)\n\n    \n.\nInfoText\n(\nYou have this many other things: \n)\n\n    \n.\nLine\n(\n34\n)\n\n    \n.\nNewLine\n(\n2\n);\n \n\n\n\n\n\nLogging\n\n\nAny exceptions thrown by a command will be logged provided NLog is configured to record errors. \nThe \nNLog configuration\n file needs to be setup with something like this: \n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nnlog\n \nxmlns=\nhttp://www.nlog-project.org/schemas/NLog.xsd\n\n      \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n\n    \ntargets\n\n        \ntarget\n \nname=\nlogfile\n \nxsi:type=\nFile\n \nfileName=\ninengine.log\n \n/\n\n    \n/targets\n\n\n    \nrules\n\n        \nlogger\n \nname=\n*\n \nminlevel=\nError\n \nwriteTo=\nlogfile\n \n/\n\n    \n/rules\n\n\n/nlog\n\n\n\n\n\n\nProgress Bar\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides a ProgressBar property to show command progress in a terminal.\nThis is how it is used:\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \n// Define the ticks (aka steps) for the command...\n\n    \nvar\n \nmaxTicks\n \n=\n \n100000\n;\n\n    \nSetProgressBarMaxTicks\n(\nmaxTicks\n);\n\n\n    \n// Do some work...\n\n    \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \nmaxTicks\n;\ni\n++)\n\n    \n{\n\n        \n// Update the command\ns progress\n\n        \nUpdateProgress\n(\ni\n);\n\n    \n}\n\n\n}", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#commands", 
            "text": "Commands are the fundamental abstraction used to run custom logic.", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#create-a-command", 
            "text": "The InEngine.Core package is required. Install it into your own Visual Studio project.  Package Manager  Install-Package InEngine.Core  Nuget CLI  nuget install InEgine.Core  .NET CLI  dotnet add package InEngine.Core  Paket CLI  paket add InEngine.Core  Adding a class that implements  InEngine.Core.ICommand  is the simplest way to create a command.  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   ICommand \n     { \n         public   void   Run () \n         { \n             Console . WriteLine ( Hello, world! ); \n         } \n     }  }   A command that implements ICommand can be run directly or  queued , but it cannot be  scheduled .\nExtending the  InEngine.Core.AbstractCommand  class adds extra functionality, like a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   AbstractCommand \n     { \n         public   override   void   Run () \n         { \n             Console . WriteLine ( Hello, world! ); \n         } \n     }  }", 
            "title": "Create a Command"
        }, 
        {
            "location": "/commands/#run-a-command", 
            "text": "Create a class that implements  InEngine.Core.IOptions  in the same assembly as the command class.\nAdd a VerbOptions attribute, from the CommandLine namespace, that defines the name of the command. \nOptional help text can also be specified in the VerbOption attribute.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method if desired.  using   CommandLine ;  using   CommandLine.Text ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyOptions   :   IOptions \n     {          [VerbOption( my-command , HelpText= My example command. )] \n         public   MyCommand   MyCommand   {   get ;   set ;   }          [HelpVerbOption] \n         public   string   GetUsage ( string   verb ) \n         { \n             return   HelpText . AutoBuild ( this ,   verb ); \n         } \n     }  }   Download the InEngine binary distribution, from the  GitHub Releases  page, that matches the version of the InEngine.Core package you included.  Copy your project's DLLs into the Plugins subdirectory included in the binary distribution. \nAdd your plugin to the  \"Plugins\" list in appsettings.config  at the root of the binary distribution.  Run your command:  inengine.exe -pMyCommandPlugin my-command", 
            "title": "Run a Command"
        }, 
        {
            "location": "/commands/#executing-arbitrary-processes", 
            "text": "It isn't necessary to create C# classes to utilize InEngine.NET.\nArbitrary commands can be run, with an argument list by leveraging the InEngine.Core plugin's  proc  command.\nThe command lists directory contents using \"ls\" with the \"-lhp\" switches:  inengine.exe -pInEngine.Core proc -c /bin/ls  -a -lhp", 
            "title": "Executing Arbitrary Processes"
        }, 
        {
            "location": "/commands/#view-available-plugins", 
            "text": "Run inengine.exe without any arguments to see a list of plugins:    ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | ||  _ \\|  _| |  _ \\ / _` | |  _ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nUsage:\nInEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  p, plugin           Plug-In to activate.\n\n  s, scheduler        Run the scheduler.\n\n  c, configuration    (Default: ./appsettings.json) The path to the \n                      configuration file.\n\n\nPlugins:\n  InEngine.Core", 
            "title": "View Available Plugins"
        }, 
        {
            "location": "/commands/#view-commands-in-a-plugin", 
            "text": "Run inengine.exe with only the plugin specified:  inengine.exe -pInEngine.Core  The  InEngine.Core  library is itself a plugin that contains queue-related and other commands. \nAs an example, this is the help output for the core plugin.    ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | ||  _ \\|  _| |  _ \\ / _` | |  _ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nPlugin: \n  Name:    InEngine.Core\n  Version: 3.x\n\n\nCommands:\n  queue:publish     Publish a command message to a queue.\n  queue:consume     Consume one or more command messages from the queue.\n  queue:length      Get the number of messages in the primary and secondary queues.\n  queue:flush       Clear the primary or secondary queues.\n  queue:republish   Republish failed messages to the queue.\n  queue:peek        Peek at messages in the primary or secondary queues.\n  echo              Echo some text to the console. Useful for end-to-end testing.\n  proc              Launch an arbitrary process.", 
            "title": "View Commands in a Plugin"
        }, 
        {
            "location": "/commands/#print-help-text-for-a-plugins-commands", 
            "text": "Run the command with the -h or --help arguments.  inengine.exe -pInEngine.Core queue:publish -h  The  InEngine.Core  plugin's command to clear the InEngine.NET queues produces this help message.   InEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  --command-plugin    Required. The name of a command plugin file, e.g. \n                      InEngine.Core.dll\n\n  --command-verb      A plugin command verb, e.g. echo\n\n  --command-class     A command class name, e.g. \n                      InEngine.Core.Commands.AlwaysSucceed. Takes precedence \n                      over --command-verb if both are specified.\n\n  --args              An optional list of arguments to publish with the \n                      command.\n\n  --secondary         (Default: False) Publish the command to the secondary \n                      queue.", 
            "title": "Print Help Text for a Plugin's Commands"
        }, 
        {
            "location": "/commands/#writing-output", 
            "text": "The  InEngine.Core.AbstractCommand  class provides some helper functions to output text to the console, for example:  public   override   void   Run ()  { \n     Line ( Display some information );  }   All of these commands append a newline to the end of the specified text:  Line ( This is some text );                    // Text color is white  Info ( Something good happened );              // Text color is green  Warning ( Something not so good happened );    // Text color is yellow  Error ( Something bad happened );              // Text color is red   These commands are similar, but they do not append a newline:  Text ( This is some text );                        // Text color is white  InfoText ( Something good happened );              // Text color is green  WarningText ( Something not so good happened );    // Text color is yellow  ErrorText ( Something bad happened );              // Text color is red   You can also display newlines:  Newline ();        // 1 newline  Newline ( 5 );       // 5 newlines  Newline ( 10 );      // 10 newlines   The methods can be chained together:  InfoText ( You have this many things:  ) \n     . Line ( 23 ) \n     . NewLine ( 2 ) \n     . InfoText ( You have this many other things:  ) \n     . Line ( 34 ) \n     . NewLine ( 2 );", 
            "title": "Writing Output"
        }, 
        {
            "location": "/commands/#logging", 
            "text": "Any exceptions thrown by a command will be logged provided NLog is configured to record errors. \nThe  NLog configuration  file needs to be setup with something like this:   ?xml version= 1.0  encoding= utf-8  ?  nlog   xmlns= http://www.nlog-project.org/schemas/NLog.xsd \n       xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n\n     targets \n         target   name= logfile   xsi:type= File   fileName= inengine.log   / \n     /targets \n\n     rules \n         logger   name= *   minlevel= Error   writeTo= logfile   / \n     /rules  /nlog", 
            "title": "Logging"
        }, 
        {
            "location": "/commands/#progress-bar", 
            "text": "The  InEngine.Core.AbstractCommand  class provides a ProgressBar property to show command progress in a terminal.\nThis is how it is used:  public   override   void   Run ()  { \n     // Define the ticks (aka steps) for the command... \n     var   maxTicks   =   100000 ; \n     SetProgressBarMaxTicks ( maxTicks ); \n\n     // Do some work... \n     for   ( var   i   =   0 ;   i   =   maxTicks ; i ++) \n     { \n         // Update the command s progress \n         UpdateProgress ( i ); \n     }  }", 
            "title": "Progress Bar"
        }, 
        {
            "location": "/scheduling/", 
            "text": "Scheduling\n\n\nCommands\n can be scheduled to run by leveraging the inengine.exe program, available as a download from a recent \nrelease\n.\n\n\nScheduling a Command\n\n\nA job schedule is created by adding a class to your plugin assembly that implements the \nInEngine.Core.IJobs\n interface.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nQuartz\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nJobs\n \n:\n \nIJobs\n\n    \n{\n\n        \npublic\n \nvoid\n \nSchedule\n(\nIScheduler\n \nscheduler\n)\n\n        \n{\n\n            \n// Schedule some jobs\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThis class is automatically discovered by the InEngine.NET scheduler.\nIt will call the Jobs.Schedule method with an initialized \nInEngine.Scheduling.Schedule\n object.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nQuartz\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nJobs\n \n:\n \nIJobs\n\n    \n{\n\n        \npublic\n \nvoid\n \nSchedule\n(\nSchedule\n \nschedule\n)\n\n        \n{\n\n            \nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryFiveMinutes\n();\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRun a command on a custom cron schedule (in this example every 15 seconds):\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nCron\n(\n15 * * * * ?\n);\n\n\n\n\n\n\nRun a command every second:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEverySecond\n();\n\n\n\n\n\n\nRun a command every minute:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryMinute\n();\n\n\n\n\n\n\nRun a command every 5 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryFiveMinutes\n();\n\n\n\n\n\n\nRun a command every 10 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryTenMinutes\n();\n\n\n\n\n\n\nRun a command every 15 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryFifteenMinutes\n();\n\n\n\n\n\n\nRun a command every 30 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryThirtyMinutes\n();\n\n\n\n\n\n\nRun a command hourly:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nHourly\n();\n\n\n\n\n\n\nRun a command hourly at a certain number of minutes past the hour (27 minutes in this example):\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nHourlyAt\n(\n27\n);\n\n\n\n\n\n\nRun a command daily:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nDaily\n();\n\n\n\n\n\n\nRun a command daily at a specific time (at 10:30pm in this example):\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nDailyAt\n(\n22\n,\n \n30\n);\n\n\n\n\n\n\nCommand State\n\n\nCommands can have properties like any C# class.\nWhen running from the command line these properties are usually initialized with command line arguments.\nWhen run by the scheduler, the properties are specified when the command is scheduled.\nFor example, this command's \nFoo\n property will be auto-wired to \"bar\" when the command is later executed by the scheduler. \n\n\nschedule\n\n    \n.\nJob\n(\nnew\n \nMyCommand\n()\n \n{\n\n        \nFoo\n \n=\n \nbar\n\n    \n})\n\n    \n.\nEveryFiveMinutes\n();\n\n\n\n\n\n\nIf it is not desirable to auto-wire a property for some reason, simply decorate the property in the command class with the \nInEngine.Core.Scheduling.DoNotAutoWireAttribute\n class. \n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nAbstractCommand\n\n    \n{\n\n\n        [DoNotAutoWire]\n\n        \npublic\n \nstring\n \nFoo\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n        \npublic\n \noverride\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \n// Foo will be null here even if it is initialized before being scheduled. \n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRunning the Scheduler\n\n\nManually from the CLI\n\n\nRunning the scheduler from the CommandLine is useful for debugging or local development:\n\n\ninengine.exe -s\n\n\n\n\n\nIt can also be run on Mac and Linux with Mono via a shell wrapper script:\n\n\n./inengine -s\n\n\n\n\n\nOn Windows as a Service\n\n\nInstalling\n\n\nRun the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. \nThe script needs to be run as an administrator. \nThe script will register the service at the location where the script is run.\n\n\nps Install.ps1\n\n\n\n\n\nUninstalling\n\n\nSimply run the \nUninstall.ps1\n script with elevated permissions to remove the service.\n\n\nps Uninstall.ps1\n\n\n\n\n\nOn Linux with Supervisor\n\n\nSupervisor is a process control system for Linux. \nIt has extensive \ndocumentation\n, but the following should be enough to get started.\n\n\nInstalling Supervisor\n\n\nThis command installs Supervisor on Ubuntu:\n\n\nsudo apt-get install supervisor\n\n\n\n\n\nConfiguring Supervisor\n\n\nSupervisor configuration files are stored in the \n/etc/supervisor/conf.d\n directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called \n/etc/supervisor/conf.d/inengine-scheduler.conf\n. \n\n\n[program:inengine-scheudler]\n\n\nprocess_name\n=\n%(program_name)s_%(process_num)02d\n\n\ndirectory\n=\n/path/to/scheduler\n\n\ncommand\n=\nmono inengine.exe -s\n\n\nautostart\n=\ntrue\n\n\nautorestart\n=\ntrue\n\n\nuser\n=\nInEngine\n\n\nnumprocs\n=\n1\n\n\nredirect_stderr\n=\ntrue\n\n\nstdout_logfile\n=\n./scheduler.log\n\n\n\n\n\n\nStarting Supervisor\n\n\nWhenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.\n\n\nsudo supervisorctl reread\nsudo supervisorctl update\n\n\n\n\n\nNow, simply start the InEngine Scheduler.\n\n\nsudo supervisorctl start inengine-scheduler:*", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling", 
            "text": "Commands  can be scheduled to run by leveraging the inengine.exe program, available as a download from a recent  release .", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling-a-command", 
            "text": "A job schedule is created by adding a class to your plugin assembly that implements the  InEngine.Core.IJobs  interface.  using   System ;  using   Quartz ;  namespace   MyCommandPlugin  { \n     public   class   Jobs   :   IJobs \n     { \n         public   void   Schedule ( IScheduler   scheduler ) \n         { \n             // Schedule some jobs \n         } \n     }  }   This class is automatically discovered by the InEngine.NET scheduler.\nIt will call the Jobs.Schedule method with an initialized  InEngine.Scheduling.Schedule  object.  using   System ;  using   Quartz ;  namespace   MyCommandPlugin  { \n     public   class   Jobs   :   IJobs \n     { \n         public   void   Schedule ( Schedule   schedule ) \n         { \n             schedule . Job ( new   MyCommand ()). EveryFiveMinutes (); \n         } \n     }  }   Run a command on a custom cron schedule (in this example every 15 seconds):  schedule . Job ( new   MyCommand ()). Cron ( 15 * * * * ? );   Run a command every second:  schedule . Job ( new   MyCommand ()). EverySecond ();   Run a command every minute:  schedule . Job ( new   MyCommand ()). EveryMinute ();   Run a command every 5 minutes:  schedule . Job ( new   MyCommand ()). EveryFiveMinutes ();   Run a command every 10 minutes:  schedule . Job ( new   MyCommand ()). EveryTenMinutes ();   Run a command every 15 minutes:  schedule . Job ( new   MyCommand ()). EveryFifteenMinutes ();   Run a command every 30 minutes:  schedule . Job ( new   MyCommand ()). EveryThirtyMinutes ();   Run a command hourly:  schedule . Job ( new   MyCommand ()). Hourly ();   Run a command hourly at a certain number of minutes past the hour (27 minutes in this example):  schedule . Job ( new   MyCommand ()). HourlyAt ( 27 );   Run a command daily:  schedule . Job ( new   MyCommand ()). Daily ();   Run a command daily at a specific time (at 10:30pm in this example):  schedule . Job ( new   MyCommand ()). DailyAt ( 22 ,   30 );", 
            "title": "Scheduling a Command"
        }, 
        {
            "location": "/scheduling/#command-state", 
            "text": "Commands can have properties like any C# class.\nWhen running from the command line these properties are usually initialized with command line arguments.\nWhen run by the scheduler, the properties are specified when the command is scheduled.\nFor example, this command's  Foo  property will be auto-wired to \"bar\" when the command is later executed by the scheduler.   schedule \n     . Job ( new   MyCommand ()   { \n         Foo   =   bar \n     }) \n     . EveryFiveMinutes ();   If it is not desirable to auto-wire a property for some reason, simply decorate the property in the command class with the  InEngine.Core.Scheduling.DoNotAutoWireAttribute  class.   using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   AbstractCommand \n     {          [DoNotAutoWire] \n         public   string   Foo   {   get ;   set ;   } \n\n         public   override   void   Run () \n         { \n             // Foo will be null here even if it is initialized before being scheduled.  \n         } \n     }  }", 
            "title": "Command State"
        }, 
        {
            "location": "/scheduling/#running-the-scheduler", 
            "text": "", 
            "title": "Running the Scheduler"
        }, 
        {
            "location": "/scheduling/#manually-from-the-cli", 
            "text": "Running the scheduler from the CommandLine is useful for debugging or local development:  inengine.exe -s  It can also be run on Mac and Linux with Mono via a shell wrapper script:  ./inengine -s", 
            "title": "Manually from the CLI"
        }, 
        {
            "location": "/scheduling/#on-windows-as-a-service", 
            "text": "", 
            "title": "On Windows as a Service"
        }, 
        {
            "location": "/scheduling/#installing", 
            "text": "Run the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. \nThe script needs to be run as an administrator. \nThe script will register the service at the location where the script is run.  ps Install.ps1", 
            "title": "Installing"
        }, 
        {
            "location": "/scheduling/#uninstalling", 
            "text": "Simply run the  Uninstall.ps1  script with elevated permissions to remove the service.  ps Uninstall.ps1", 
            "title": "Uninstalling"
        }, 
        {
            "location": "/scheduling/#on-linux-with-supervisor", 
            "text": "Supervisor is a process control system for Linux. \nIt has extensive  documentation , but the following should be enough to get started.", 
            "title": "On Linux with Supervisor"
        }, 
        {
            "location": "/scheduling/#installing-supervisor", 
            "text": "This command installs Supervisor on Ubuntu:  sudo apt-get install supervisor", 
            "title": "Installing Supervisor"
        }, 
        {
            "location": "/scheduling/#configuring-supervisor", 
            "text": "Supervisor configuration files are stored in the  /etc/supervisor/conf.d  directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called  /etc/supervisor/conf.d/inengine-scheduler.conf .   [program:inengine-scheudler]  process_name = %(program_name)s_%(process_num)02d  directory = /path/to/scheduler  command = mono inengine.exe -s  autostart = true  autorestart = true  user = InEngine  numprocs = 1  redirect_stderr = true  stdout_logfile = ./scheduler.log", 
            "title": "Configuring Supervisor"
        }, 
        {
            "location": "/scheduling/#starting-supervisor", 
            "text": "Whenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.  sudo supervisorctl reread\nsudo supervisorctl update  Now, simply start the InEngine Scheduler.  sudo supervisorctl start inengine-scheduler:*", 
            "title": "Starting Supervisor"
        }, 
        {
            "location": "/queuing/", 
            "text": "Queuing\n\n\nInEngine.NET's queue functionality allows for commands to be run in the background with a simple publish/consume model. \n\n\nPrerequisites\n\n\nRedis is required to use the InEngine.NET queue feature. \nIt can be installed on Ubuntu with this command:\n\n\nsudo apt-get install redis-server\n\n\n\n\n\nStart Redis with this command:\n\n\nsudo service redis start\n\n\n\n\n\n\nIt is highly recommended to \nset a password\n for Redis.\n\n\n\n\nPublishing Commands\n\n\nFrom Code\n\n\nCommands\n can be published programmatically with the \nInEngine.Core.Queuing.Broker\n class:\n\n\nBroker\n.\nMake\n().\nPublish\n(\nnew\n \nMyCommand\n());\n\n\n\n\n\n\nOr publish to the secondary queue:\n\n\nBroker\n.\nMake\n(\ntrue\n).\nPublish\n(\nnew\n \nMyCommand\n());\n\n\n\n\n\n\nFrom the Command Line\n\n\nCommands can be published from the command line as well.\nNote that all queue commands reside in the \nInEngine.Core\n plugin.\nThis is an example of how to publish a command from the CLI by specifying the command's plugin, class name, and arguments:\n\n\ninengine.exe -pInEngine.Core queue:publish --command-plugin\n=\nMyCommandPlugin.dll --command-class\n=\nMyCommand --args \ntext=bar\n\n\n\n\n\n\nThere is an \"Echo\" command in the \nInEngine.Core\n package. It is useful for end-to-end testing with the queue feature.\n\n\ninengine.exe -pInEngine.Core queue:publish --command-plugin\n=\nInEngine.Core.dll --command-class\n=\nInEngine.Core.Commands.Echo --args \ntext=foo\n\n\n\n\n\n\nThe command verb can also be specified instead of the full class name:\n\n\ninengine.exe -pInEngine.Core queue:publish --command-plugin\n=\nInEngine.Core.dll --command-verb\n=\necho--args \ntext=foo\n\n\n\n\n\n\nConsuming Commands\n\n\nFrom Code\n\n\nConsuming a command is also accomplished with the Broker class:\n\n\nBroker\n.\nMake\n().\nConsume\n();\n\n\n\n\n\n\nThe make method takes an optional second argument to indicate if the secondary queue should be used instead of the primary queue.\n\n\n// Uses secondary queue.\n\n\nBroker\n.\nMake\n(\ntrue\n).\nConsume\n();\n\n\n\n\n\n\nCommands can be consumed from the command line as well with this simple command:\n\n\nFrom the Command Line\n\n\ninengine.exe -pInEngine.Core queue:consume\n\n\n\n\n\nUse the \n--secondary\n argument to consume the secondary queue instead of the primary queue:\n\n\ninengine.exe -pInEngine.Core queue:consume --secondary\n\n\n\n\n\nWith the Scheduler\n\n\nThe InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of \nways to run the scheduler\n.\n\n\nExamining the Queue\n\n\nViewing Queue Lengths\n\n\nThe \nqueue:length\n command shows a quick summary of pending, in-progress, and failed commands in the primary and secondary queues:\n\n\ninengine.exe -pInEngine.Core queue:length\n\n\n\n\n\nPeek at Commands\n\n\nThe \nqueue:peek\n command allows for queued commands to be inspected:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --in-progress --failed\n\n\n\n\n\nIt is of course possible to peek in the secondary queues:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --secondary\n\n\n\n\n\nQueued commands can be viewed in JSON which maybe useful for debugging:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --json\n\n\n\n\n\nBy default, up to 10 messages will be retrieved, but the number is configurable:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --limit\n=\n100\n\n\n\n\n\n\nThe a paginated slice of the queue can be retrieved using the offset argument.\nFor example, this queue:peek call retrieves the 100-200 queued commands:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --limit\n=\n100\n --offset\n=\n100\n\n\n\n\n\n\nHandling Failed Commands\n\n\nCommands that throw an exception are put in a special \"failed\" queue. \nThey can be republished with the \nqueue:republish\n command:\n\n\ninengine.exe -pInEngine.Core queue:republish\n\n\n\n\n\nFailed secondary queue commands can be republished as well:\n\n\ninengine.exe -pInEngine.Core queue:republish --secondary\n\n\n\n\n\nBy default, only 100 failed commands are republished at a time.\nThe is configurable:\n\n\ninengine.exe -pInEngine.Core queue:republish --limit\n=\n1000\n\n\n\n\n\n\nPrimary and Secondary Queue\n\n\nOther than the fact that the primary queue is used by default, there is no difference between the primary and secondary queues. \nHowever, it is often desirable to use two queues. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.\n\n\nWhat about 3, 4, or 900 queues? Managing numerous queues gets to be a pain and, practically speaking, is probably unnecessary.\nIf it is desirable, different \nconfiguration files\n can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it with the -c argument:\n\n\ninengine.exe -cMyCustomSettingsFile.json -pInEngine.Core queue:consume\n\n\n\n\n\nMessage Compression\n\n\nMessages can be compressed when saved in the queue. \nIt is important to understand the trade-offs of this feature before enabling it.\nIf the queued commands are too small to benefit from being compressed, then compressing them wastes resources.\nCompressing messages takes more CPU resources and might negatively impact queue throughput if the queued commands do not have a lot of internal state.\n\n\nIf the commands have a lot of internal state, then this feature will reduce the queue's memory consumption.\nAlso, in a high-throughput scenario, where network bandwidth is limited, this feature can greatly reduce the amount of bandwidth used.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#queuing", 
            "text": "InEngine.NET's queue functionality allows for commands to be run in the background with a simple publish/consume model.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#prerequisites", 
            "text": "Redis is required to use the InEngine.NET queue feature. \nIt can be installed on Ubuntu with this command:  sudo apt-get install redis-server  Start Redis with this command:  sudo service redis start  \nIt is highly recommended to  set a password  for Redis.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/queuing/#publishing-commands", 
            "text": "", 
            "title": "Publishing Commands"
        }, 
        {
            "location": "/queuing/#from-code", 
            "text": "Commands  can be published programmatically with the  InEngine.Core.Queuing.Broker  class:  Broker . Make (). Publish ( new   MyCommand ());   Or publish to the secondary queue:  Broker . Make ( true ). Publish ( new   MyCommand ());", 
            "title": "From Code"
        }, 
        {
            "location": "/queuing/#from-the-command-line", 
            "text": "Commands can be published from the command line as well.\nNote that all queue commands reside in the  InEngine.Core  plugin.\nThis is an example of how to publish a command from the CLI by specifying the command's plugin, class name, and arguments:  inengine.exe -pInEngine.Core queue:publish --command-plugin = MyCommandPlugin.dll --command-class = MyCommand --args  text=bar   There is an \"Echo\" command in the  InEngine.Core  package. It is useful for end-to-end testing with the queue feature.  inengine.exe -pInEngine.Core queue:publish --command-plugin = InEngine.Core.dll --command-class = InEngine.Core.Commands.Echo --args  text=foo   The command verb can also be specified instead of the full class name:  inengine.exe -pInEngine.Core queue:publish --command-plugin = InEngine.Core.dll --command-verb = echo--args  text=foo", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#consuming-commands", 
            "text": "", 
            "title": "Consuming Commands"
        }, 
        {
            "location": "/queuing/#from-code_1", 
            "text": "Consuming a command is also accomplished with the Broker class:  Broker . Make (). Consume ();   The make method takes an optional second argument to indicate if the secondary queue should be used instead of the primary queue.  // Uses secondary queue.  Broker . Make ( true ). Consume ();   Commands can be consumed from the command line as well with this simple command:", 
            "title": "From Code"
        }, 
        {
            "location": "/queuing/#from-the-command-line_1", 
            "text": "inengine.exe -pInEngine.Core queue:consume  Use the  --secondary  argument to consume the secondary queue instead of the primary queue:  inengine.exe -pInEngine.Core queue:consume --secondary", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#with-the-scheduler", 
            "text": "The InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of  ways to run the scheduler .", 
            "title": "With the Scheduler"
        }, 
        {
            "location": "/queuing/#examining-the-queue", 
            "text": "", 
            "title": "Examining the Queue"
        }, 
        {
            "location": "/queuing/#viewing-queue-lengths", 
            "text": "The  queue:length  command shows a quick summary of pending, in-progress, and failed commands in the primary and secondary queues:  inengine.exe -pInEngine.Core queue:length", 
            "title": "Viewing Queue Lengths"
        }, 
        {
            "location": "/queuing/#peek-at-commands", 
            "text": "The  queue:peek  command allows for queued commands to be inspected:  inengine.exe -pInEngine.Core queue:peek --pending --in-progress --failed  It is of course possible to peek in the secondary queues:  inengine.exe -pInEngine.Core queue:peek --pending --secondary  Queued commands can be viewed in JSON which maybe useful for debugging:  inengine.exe -pInEngine.Core queue:peek --pending --json  By default, up to 10 messages will be retrieved, but the number is configurable:  inengine.exe -pInEngine.Core queue:peek --pending --limit = 100   The a paginated slice of the queue can be retrieved using the offset argument.\nFor example, this queue:peek call retrieves the 100-200 queued commands:  inengine.exe -pInEngine.Core queue:peek --pending --limit = 100  --offset = 100", 
            "title": "Peek at Commands"
        }, 
        {
            "location": "/queuing/#handling-failed-commands", 
            "text": "Commands that throw an exception are put in a special \"failed\" queue. \nThey can be republished with the  queue:republish  command:  inengine.exe -pInEngine.Core queue:republish  Failed secondary queue commands can be republished as well:  inengine.exe -pInEngine.Core queue:republish --secondary  By default, only 100 failed commands are republished at a time.\nThe is configurable:  inengine.exe -pInEngine.Core queue:republish --limit = 1000", 
            "title": "Handling Failed Commands"
        }, 
        {
            "location": "/queuing/#primary-and-secondary-queue", 
            "text": "Other than the fact that the primary queue is used by default, there is no difference between the primary and secondary queues. \nHowever, it is often desirable to use two queues. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.  What about 3, 4, or 900 queues? Managing numerous queues gets to be a pain and, practically speaking, is probably unnecessary.\nIf it is desirable, different  configuration files  can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it with the -c argument:  inengine.exe -cMyCustomSettingsFile.json -pInEngine.Core queue:consume", 
            "title": "Primary and Secondary Queue"
        }, 
        {
            "location": "/queuing/#message-compression", 
            "text": "Messages can be compressed when saved in the queue. \nIt is important to understand the trade-offs of this feature before enabling it.\nIf the queued commands are too small to benefit from being compressed, then compressing them wastes resources.\nCompressing messages takes more CPU resources and might negatively impact queue throughput if the queued commands do not have a lot of internal state.  If the commands have a lot of internal state, then this feature will reduce the queue's memory consumption.\nAlso, in a high-throughput scenario, where network bandwidth is limited, this feature can greatly reduce the amount of bandwidth used.", 
            "title": "Message Compression"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nConfiguration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution. The -c, --configuration argument can also be used to specify an alternate configuration file.\n\n\n{\n\n  \nInEngine\n:\n \n{\n\n    \nPlugins\n:\n \n[\n\n      \npath/to/MyCommandPlugin\n\n    \n],\n\n    \nQueue\n:\n \n{\n\n      \nUseCompression\n:\n \nfalse\n,\n\n      \nPrimaryQueueConsumers\n:\n  \n16\n,\n\n      \nSecondaryQueueConsumers\n:\n \n4\n,\n\n      \nQueueName\n:\n \nInEngine:Queue\n,\n\n      \nRedisHost\n:\n \nlocalhost\n,\n\n      \nRedisPort\n:\n \n6379\n,\n\n      \nRedisDb\n:\n \n0\n,\n\n      \nRedisPassword\n:\n \n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nTop-level Settings\n\n\n\n\n\n\n\n\nSetting\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPlugins\n\n\narray of strings\n\n\nA list of paths of plugin assemblies, with \".dll\" omitted from the assembly name.\n\n\n\n\n\n\n\n\nQueue Settings\n\n\n\n\n\n\n\n\nSetting\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUseCompression\n\n\nbool\n\n\nA situation performance optimization that compresses queued messages.\n\n\n\n\n\n\nPrimaryQueueConsumers\n\n\nstring\n\n\nThe number of consumers to schedule for the secondary queue.\n\n\n\n\n\n\nSecondaryQueueConsumers\n\n\nstring\n\n\nThe number of consumers to schedule for the secondary queue.\n\n\n\n\n\n\nQueueName\n\n\nstring\n\n\nThe base name of the queue, used to form the Redis Queue keys.\n\n\n\n\n\n\nRedisHost\n\n\nstring\n\n\nThe Redis hostname to connect to.\n\n\n\n\n\n\nRedisPort\n\n\ninteger\n\n\nRedis's port.\n\n\n\n\n\n\nRedisDb\n\n\ninteger\n\n\nThe Redis database - 0-15\n\n\n\n\n\n\nRedisPassword\n\n\nstring\n\n\nThe Redis auth password", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "Configuration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution. The -c, --configuration argument can also be used to specify an alternate configuration file.  { \n   InEngine :   { \n     Plugins :   [ \n       path/to/MyCommandPlugin \n     ], \n     Queue :   { \n       UseCompression :   false , \n       PrimaryQueueConsumers :    16 , \n       SecondaryQueueConsumers :   4 , \n       QueueName :   InEngine:Queue , \n       RedisHost :   localhost , \n       RedisPort :   6379 , \n       RedisDb :   0 , \n       RedisPassword :   \n     } \n   }  }", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#top-level-settings", 
            "text": "Setting  Type  Description      Plugins  array of strings  A list of paths of plugin assemblies, with \".dll\" omitted from the assembly name.", 
            "title": "Top-level Settings"
        }, 
        {
            "location": "/configuration/#queue-settings", 
            "text": "Setting  Type  Description      UseCompression  bool  A situation performance optimization that compresses queued messages.    PrimaryQueueConsumers  string  The number of consumers to schedule for the secondary queue.    SecondaryQueueConsumers  string  The number of consumers to schedule for the secondary queue.    QueueName  string  The base name of the queue, used to form the Redis Queue keys.    RedisHost  string  The Redis hostname to connect to.    RedisPort  integer  Redis's port.    RedisDb  integer  The Redis database - 0-15    RedisPassword  string  The Redis auth password", 
            "title": "Queue Settings"
        }
    ]
}