{
    "docs": [
        {
            "location": "/", 
            "text": "InEngine.NET is a plugin-based software application that allows commands to be \nqueued\n, \nscheduled\n, and run directly.\n\n\nHow does it work?\n\n\nInEngine.NET uses a plugin system to dynamically load .NET assemblies and execute code. \nIt also has a built-in command for launching external non-.NET programs.\n\n\nGet started by pulling the binaries from the \nlatest release\n on GitHub.\n\n\nThen run a command the \necho\n command from the core plugin:\n\n\ninengine.exe -pInEngine.Core \necho\n --text\nHello, world\n\n\n\n\n\n\nOr if you're a Linux or Mac OS X fan (like me!), use the \ninengine\n shell script (\nMono\n is required):\n\n\ninengine -pInEngine.Core \necho\n --text\nHello, world\n\n\n\n\n\n\nInstead of downloading binaries and runtimes, you can pull the latest Docker image:\n\n\ndocker pull ethanhann/inengine:latest\n\n\n\n\n\nNow run a command in a container:\n\n\ndocker run --rm inengine -pInEngine.Core \necho\n --text\nHello, world\n\n\n\n\n\n\nHow does queueing work?\n\n\nThere are a lot of \nqueuing\n features, but this is the gist...\n\n\nWant to queue our example echo command to run in the background or possibly on another server?\n\n\nUse the core plugin's \nqueue:publish\n command:\n\n\ninengine.exe -pInEngine.Core queue:publish --command-plugin\n=\nInEngine.Core.dll --command-verb\n=\necho\n --args \ntext=Hello, world\n\n\n\n\n\n\nHow do we consume that queued echo command?\n\n\nUse the core plugin's \nqueue:consume\n command of course:\n\n\ninengine.exe -pInEngine.Core queue:consume\n\n\n\n\n\nHow do I run non-.NET commands?\n\n\nThere is a special \nproc\n command in the core plugin that allows for the execution of any program you can run at the command line. \n\n\nFor example, create a python script called \nhelloworld.py\n that contains this:\n\n\nprint\n \nHello, world!\n\n\n\n\n\n\nNow execute it with the \nproc\n command:\n\n\ninengine -pInEngine.Core proc --command\n=\n/usr/bin/python --args\n=\nhelloworld.py", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#how-does-it-work", 
            "text": "InEngine.NET uses a plugin system to dynamically load .NET assemblies and execute code. \nIt also has a built-in command for launching external non-.NET programs.  Get started by pulling the binaries from the  latest release  on GitHub.  Then run a command the  echo  command from the core plugin:  inengine.exe -pInEngine.Core  echo  --text Hello, world   Or if you're a Linux or Mac OS X fan (like me!), use the  inengine  shell script ( Mono  is required):  inengine -pInEngine.Core  echo  --text Hello, world   Instead of downloading binaries and runtimes, you can pull the latest Docker image:  docker pull ethanhann/inengine:latest  Now run a command in a container:  docker run --rm inengine -pInEngine.Core  echo  --text Hello, world", 
            "title": "How does it work?"
        }, 
        {
            "location": "/#how-does-queueing-work", 
            "text": "There are a lot of  queuing  features, but this is the gist...  Want to queue our example echo command to run in the background or possibly on another server?  Use the core plugin's  queue:publish  command:  inengine.exe -pInEngine.Core queue:publish --command-plugin = InEngine.Core.dll --command-verb = echo  --args  text=Hello, world   How do we consume that queued echo command?  Use the core plugin's  queue:consume  command of course:  inengine.exe -pInEngine.Core queue:consume", 
            "title": "How does queueing work?"
        }, 
        {
            "location": "/#how-do-i-run-non-net-commands", 
            "text": "There is a special  proc  command in the core plugin that allows for the execution of any program you can run at the command line.   For example, create a python script called  helloworld.py  that contains this:  print   Hello, world!   Now execute it with the  proc  command:  inengine -pInEngine.Core proc --command = /usr/bin/python --args = helloworld.py", 
            "title": "How do I run non-.NET commands?"
        }, 
        {
            "location": "/commands/", 
            "text": "Commands\n\n\nCommands are the fundamental abstraction used to run custom logic.\n\n\nCreate a Command\n\n\nThe InEngine.Core package is required. Install it into your own Visual Studio project.\n\n\nPackage Manager\n\n\nInstall-Package InEngine.Core\n\n\n\n\n\nNuget CLI\n\n\nnuget install InEgine.Core\n\n\n\n\n\n.NET CLI\n\n\ndotnet add package InEngine.Core\n\n\n\n\n\nPaket CLI\n\n\npaket add InEngine.Core\n\n\n\n\n\nAdding a class that implements \nInEngine.Core.ICommand\n is the simplest way to create a command.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nICommand\n\n    \n{\n\n        \npublic\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \nConsole\n.\nWriteLine\n(\nHello, world!\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nA command that implements ICommand can be run directly or \nqueued\n, but it cannot be \nscheduled\n.\nExtending the \nInEngine.Core.AbstractCommand\n class adds extra functionality, like a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nAbstractCommand\n\n    \n{\n\n        \npublic\n \noverride\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \nConsole\n.\nWriteLine\n(\nHello, world!\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRun a Command\n\n\nCreate a class that implements \nInEngine.Core.IOptions\n in the same assembly as the command class.\nAdd a VerbOptions attribute, from the CommandLine namespace, that defines the name of the command. \nOptional help text can also be specified in the VerbOption attribute.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method if desired.\n\n\nusing\n \nCommandLine\n;\n\n\nusing\n \nCommandLine.Text\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyOptions\n \n:\n \nIOptions\n\n    \n{\n\n\n        [VerbOption(\nmy-command\n, HelpText=\nMy example command.\n)]\n\n        \npublic\n \nMyCommand\n \nMyCommand\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n\n        [HelpVerbOption]\n\n        \npublic\n \nstring\n \nGetUsage\n(\nstring\n \nverb\n)\n\n        \n{\n\n            \nreturn\n \nHelpText\n.\nAutoBuild\n(\nthis\n,\n \nverb\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDownload the InEngine binary distribution, from the \nGitHub Releases\n page, that matches the version of the InEngine.Core package you included.\n\n\nCopy your project's DLLs into the Plugins subdirectory included in the binary distribution. \nAdd your plugin to the \n\"Plugins\" list in appsettings.config\n at the root of the binary distribution.\n\n\nRun your command:\n\n\ninengine.exe -pMyCommandPlugin my-command\n\n\n\n\n\nExecuting Arbitrary Processes\n\n\nIt isn't necessary to create C# classes to utilize InEngine.NET.\nArbitrary commands can be run, with an argument list by leveraging the InEngine.Core plugin's \nproc\n command.\nThe command lists directory contents using \"ls\" with the \"-lhp\" switches:\n\n\ninengine.exe -pInEngine.Core proc -c\n/bin/ls\n -a\n-lhp\n\n\n\n\n\n\nView Available Plugins\n\n\nRun inengine.exe without any arguments to see a list of plugins:\n\n\n  ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | || \n_ \\|  _| | \n_ \\ / _` | | \n_ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nUsage:\nInEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  p, plugin           Plug-In to activate.\n\n  s, scheduler        Run the scheduler.\n\n  c, configuration    (Default: ./appsettings.json) The path to the \n                      configuration file.\n\n\nPlugins:\n  InEngine.Core\n\n\n\n\n\nView Commands in a Plugin\n\n\nRun inengine.exe with only the plugin specified:\n\n\ninengine.exe -pInEngine.Core\n\n\n\n\n\nThe \nInEngine.Core\n library is itself a plugin that contains queue-related and other commands. \nAs an example, this is the help output for the core plugin.\n\n\n  ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | || \n_ \\|  _| | \n_ \\ / _` | | \n_ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nPlugin: \n  Name:    InEngine.Core\n  Version: 3.x\n\n\nCommands:\n  queue:publish     Publish a command message to a queue.\n  queue:consume     Consume one or more command messages from the queue.\n  queue:length      Get the number of messages in the primary and secondary queues.\n  queue:flush       Clear the primary or secondary queues.\n  queue:republish   Republish failed messages to the queue.\n  queue:peek        Peek at messages in the primary or secondary queues.\n  echo              Echo some text to the console. Useful for end-to-end testing.\n  proc              Launch an arbitrary process.\n\n\n\n\n\nPrint Help Text for a Plugin's Commands\n\n\nRun the command with the -h or --help arguments.\n\n\ninengine.exe -pInEngine.Core queue:publish -h\n\n\n\n\n\nThe \nInEngine.Core\n plugin's command to clear the InEngine.NET queues produces this help message. \n\n\nInEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  --command-plugin    Required. The name of a command plugin file, e.g. \n                      InEngine.Core.dll\n\n  --command-verb      A plugin command verb, e.g. echo\n\n  --command-class     A command class name, e.g. \n                      InEngine.Core.Commands.AlwaysSucceed. Takes precedence \n                      over --command-verb if both are specified.\n\n  --args              An optional list of arguments to publish with the \n                      command.\n\n  --secondary         (Default: False) Publish the command to the secondary \n                      queue.\n\n\n\n\n\nWriting Output\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides some helper functions to output text to the console, for example:\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \nLine\n(\nDisplay some information\n);\n\n\n}\n\n\n\n\n\n\nAll of these commands append a newline to the end of the specified text:\n\n\nLine\n(\nThis is some text\n);\n                  \n// Text color is white\n\n\nInfo\n(\nSomething good happened\n);\n            \n// Text color is green\n\n\nWarning\n(\nSomething not so good happened\n);\n  \n// Text color is yellow\n\n\nError\n(\nSomething bad happened\n);\n            \n// Text color is red\n\n\n\n\n\n\nThese commands are similar, but they do not append a newline:\n\n\nText\n(\nThis is some text\n);\n                      \n// Text color is white\n\n\nInfoText\n(\nSomething good happened\n);\n            \n// Text color is green\n\n\nWarningText\n(\nSomething not so good happened\n);\n  \n// Text color is yellow\n\n\nErrorText\n(\nSomething bad happened\n);\n            \n// Text color is red\n\n\n\n\n\n\nYou can also display newlines:\n\n\nNewline\n();\n      \n// 1 newline\n\n\nNewline\n(\n5\n);\n     \n// 5 newlines\n\n\nNewline\n(\n10\n);\n    \n// 10 newlines\n\n\n\n\n\n\nThe methods can be chained together:\n\n\nInfoText\n(\nYou have this many things: \n)\n\n    \n.\nLine\n(\n23\n)\n\n    \n.\nNewLine\n(\n2\n)\n\n    \n.\nInfoText\n(\nYou have this many other things: \n)\n\n    \n.\nLine\n(\n34\n)\n\n    \n.\nNewLine\n(\n2\n);\n \n\n\n\n\n\nLogging\n\n\nAny exceptions thrown by a command will be logged provided NLog is configured to record errors. \nThe \nNLog configuration\n file needs to be setup with something like this: \n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nnlog\n \nxmlns=\nhttp://www.nlog-project.org/schemas/NLog.xsd\n\n      \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n\n    \ntargets\n\n        \ntarget\n \nname=\nlogfile\n \nxsi:type=\nFile\n \nfileName=\ninengine.log\n \n/\n\n    \n/targets\n\n\n    \nrules\n\n        \nlogger\n \nname=\n*\n \nminlevel=\nError\n \nwriteTo=\nlogfile\n \n/\n\n    \n/rules\n\n\n/nlog\n\n\n\n\n\n\nProgress Bar\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides a ProgressBar property to show command progress in a terminal.\nThis is how it is used:\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \n// Define the ticks (aka steps) for the command...\n\n    \nvar\n \nmaxTicks\n \n=\n \n100000\n;\n\n    \nSetProgressBarMaxTicks\n(\nmaxTicks\n);\n\n\n    \n// Do some work...\n\n    \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \nmaxTicks\n;\ni\n++)\n\n    \n{\n\n        \n// Update the command\ns progress\n\n        \nUpdateProgress\n(\ni\n);\n\n    \n}\n\n\n}", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#commands", 
            "text": "Commands are the fundamental abstraction used to run custom logic.", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#create-a-command", 
            "text": "The InEngine.Core package is required. Install it into your own Visual Studio project.  Package Manager  Install-Package InEngine.Core  Nuget CLI  nuget install InEgine.Core  .NET CLI  dotnet add package InEngine.Core  Paket CLI  paket add InEngine.Core  Adding a class that implements  InEngine.Core.ICommand  is the simplest way to create a command.  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   ICommand \n     { \n         public   void   Run () \n         { \n             Console . WriteLine ( Hello, world! ); \n         } \n     }  }   A command that implements ICommand can be run directly or  queued , but it cannot be  scheduled .\nExtending the  InEngine.Core.AbstractCommand  class adds extra functionality, like a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   AbstractCommand \n     { \n         public   override   void   Run () \n         { \n             Console . WriteLine ( Hello, world! ); \n         } \n     }  }", 
            "title": "Create a Command"
        }, 
        {
            "location": "/commands/#run-a-command", 
            "text": "Create a class that implements  InEngine.Core.IOptions  in the same assembly as the command class.\nAdd a VerbOptions attribute, from the CommandLine namespace, that defines the name of the command. \nOptional help text can also be specified in the VerbOption attribute.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method if desired.  using   CommandLine ;  using   CommandLine.Text ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyOptions   :   IOptions \n     {          [VerbOption( my-command , HelpText= My example command. )] \n         public   MyCommand   MyCommand   {   get ;   set ;   }          [HelpVerbOption] \n         public   string   GetUsage ( string   verb ) \n         { \n             return   HelpText . AutoBuild ( this ,   verb ); \n         } \n     }  }   Download the InEngine binary distribution, from the  GitHub Releases  page, that matches the version of the InEngine.Core package you included.  Copy your project's DLLs into the Plugins subdirectory included in the binary distribution. \nAdd your plugin to the  \"Plugins\" list in appsettings.config  at the root of the binary distribution.  Run your command:  inengine.exe -pMyCommandPlugin my-command", 
            "title": "Run a Command"
        }, 
        {
            "location": "/commands/#executing-arbitrary-processes", 
            "text": "It isn't necessary to create C# classes to utilize InEngine.NET.\nArbitrary commands can be run, with an argument list by leveraging the InEngine.Core plugin's  proc  command.\nThe command lists directory contents using \"ls\" with the \"-lhp\" switches:  inengine.exe -pInEngine.Core proc -c /bin/ls  -a -lhp", 
            "title": "Executing Arbitrary Processes"
        }, 
        {
            "location": "/commands/#view-available-plugins", 
            "text": "Run inengine.exe without any arguments to see a list of plugins:    ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | ||  _ \\|  _| |  _ \\ / _` | |  _ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nUsage:\nInEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  p, plugin           Plug-In to activate.\n\n  s, scheduler        Run the scheduler.\n\n  c, configuration    (Default: ./appsettings.json) The path to the \n                      configuration file.\n\n\nPlugins:\n  InEngine.Core", 
            "title": "View Available Plugins"
        }, 
        {
            "location": "/commands/#view-commands-in-a-plugin", 
            "text": "Run inengine.exe with only the plugin specified:  inengine.exe -pInEngine.Core  The  InEngine.Core  library is itself a plugin that contains queue-related and other commands. \nAs an example, this is the help output for the core plugin.    ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | ||  _ \\|  _| |  _ \\ / _` | |  _ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nPlugin: \n  Name:    InEngine.Core\n  Version: 3.x\n\n\nCommands:\n  queue:publish     Publish a command message to a queue.\n  queue:consume     Consume one or more command messages from the queue.\n  queue:length      Get the number of messages in the primary and secondary queues.\n  queue:flush       Clear the primary or secondary queues.\n  queue:republish   Republish failed messages to the queue.\n  queue:peek        Peek at messages in the primary or secondary queues.\n  echo              Echo some text to the console. Useful for end-to-end testing.\n  proc              Launch an arbitrary process.", 
            "title": "View Commands in a Plugin"
        }, 
        {
            "location": "/commands/#print-help-text-for-a-plugins-commands", 
            "text": "Run the command with the -h or --help arguments.  inengine.exe -pInEngine.Core queue:publish -h  The  InEngine.Core  plugin's command to clear the InEngine.NET queues produces this help message.   InEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  --command-plugin    Required. The name of a command plugin file, e.g. \n                      InEngine.Core.dll\n\n  --command-verb      A plugin command verb, e.g. echo\n\n  --command-class     A command class name, e.g. \n                      InEngine.Core.Commands.AlwaysSucceed. Takes precedence \n                      over --command-verb if both are specified.\n\n  --args              An optional list of arguments to publish with the \n                      command.\n\n  --secondary         (Default: False) Publish the command to the secondary \n                      queue.", 
            "title": "Print Help Text for a Plugin's Commands"
        }, 
        {
            "location": "/commands/#writing-output", 
            "text": "The  InEngine.Core.AbstractCommand  class provides some helper functions to output text to the console, for example:  public   override   void   Run ()  { \n     Line ( Display some information );  }   All of these commands append a newline to the end of the specified text:  Line ( This is some text );                    // Text color is white  Info ( Something good happened );              // Text color is green  Warning ( Something not so good happened );    // Text color is yellow  Error ( Something bad happened );              // Text color is red   These commands are similar, but they do not append a newline:  Text ( This is some text );                        // Text color is white  InfoText ( Something good happened );              // Text color is green  WarningText ( Something not so good happened );    // Text color is yellow  ErrorText ( Something bad happened );              // Text color is red   You can also display newlines:  Newline ();        // 1 newline  Newline ( 5 );       // 5 newlines  Newline ( 10 );      // 10 newlines   The methods can be chained together:  InfoText ( You have this many things:  ) \n     . Line ( 23 ) \n     . NewLine ( 2 ) \n     . InfoText ( You have this many other things:  ) \n     . Line ( 34 ) \n     . NewLine ( 2 );", 
            "title": "Writing Output"
        }, 
        {
            "location": "/commands/#logging", 
            "text": "Any exceptions thrown by a command will be logged provided NLog is configured to record errors. \nThe  NLog configuration  file needs to be setup with something like this:   ?xml version= 1.0  encoding= utf-8  ?  nlog   xmlns= http://www.nlog-project.org/schemas/NLog.xsd \n       xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n\n     targets \n         target   name= logfile   xsi:type= File   fileName= inengine.log   / \n     /targets \n\n     rules \n         logger   name= *   minlevel= Error   writeTo= logfile   / \n     /rules  /nlog", 
            "title": "Logging"
        }, 
        {
            "location": "/commands/#progress-bar", 
            "text": "The  InEngine.Core.AbstractCommand  class provides a ProgressBar property to show command progress in a terminal.\nThis is how it is used:  public   override   void   Run ()  { \n     // Define the ticks (aka steps) for the command... \n     var   maxTicks   =   100000 ; \n     SetProgressBarMaxTicks ( maxTicks ); \n\n     // Do some work... \n     for   ( var   i   =   0 ;   i   =   maxTicks ; i ++) \n     { \n         // Update the command s progress \n         UpdateProgress ( i ); \n     }  }", 
            "title": "Progress Bar"
        }, 
        {
            "location": "/scheduling/", 
            "text": "Scheduling\n\n\nCommands\n can be run at certain times on recurring schedules.\n\n\nScheduling a Command\n\n\nA job schedule is created by adding a class to your plugin assembly that implements the \nInEngine.Core.IJobs\n interface.\n\n\nusing\n \nSystem\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nJobs\n \n:\n \nIJobs\n\n    \n{\n\n        \npublic\n \nvoid\n \nSchedule\n(\nSchedule\n \nschedule\n)\n\n        \n{\n\n            \n// Schedule some jobs\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe InEngine.NET scheduler automatically discovers this class.\nIt will call the Jobs.Schedule method with an initialized \nInEngine.Scheduling.Schedule\n object.\n\n\nusing\n \nSystem\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nJobs\n \n:\n \nIJobs\n\n    \n{\n\n        \npublic\n \nvoid\n \nSchedule\n(\nSchedule\n \nschedule\n)\n\n        \n{\n\n            \n/* \n\n\n             * Run MyCommand every five minutes. \n\n\n             */\n\n            \nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryFiveMinutes\n();\n\n\n            \n/* \n\n\n             * Run a lambda expression every ten minutes. \n\n\n             */\n\n            \nschedule\n.\nJob\n(()\n \n=\n \nConsole\n.\nWriteLine\n(\nHello, world!\n)).\nEveryTenMinutes\n();\n\n\n            \n/* \n\n\n             * Run a parameterless method every five minutes. \n\n\n             */\n\n            \nschedule\n.\nJob\n(()\n \n=\n \nFoo\n.\nBar\n).\nEverySecond\n();\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRun a command on a custom cron schedule (in this example every 15 seconds):\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nCron\n(\n15 * * * * ?\n);\n\n\n\n\n\n\nRun a command every second:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEverySecond\n();\n\n\n\n\n\n\nRun a command every minute:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryMinute\n();\n\n\n\n\n\n\nRun a command every 5 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryFiveMinutes\n();\n\n\n\n\n\n\nRun a command every 10 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryTenMinutes\n();\n\n\n\n\n\n\nRun a command every 15 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryFifteenMinutes\n();\n\n\n\n\n\n\nRun a command every 30 minutes:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nEveryThirtyMinutes\n();\n\n\n\n\n\n\nRun a command hourly:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nHourly\n();\n\n\n\n\n\n\nRun a command hourly at a certain number of minutes past the hour (27 minutes in this example):\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nHourlyAt\n(\n27\n);\n\n\n\n\n\n\nRun a command daily:\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nDaily\n();\n\n\n\n\n\n\nRun a command daily at a specific time (at 10:30pm in this example):\n\n\nschedule\n.\nJob\n(\nnew\n \nMyCommand\n()).\nDailyAt\n(\n22\n,\n \n30\n);\n\n\n\n\n\n\nCommand State\n\n\nCommands can have properties like any C# class.\nWhen running from the command line these properties are usually initialized with command line arguments.\nWhen run by the scheduler, the properties are specified when the command is scheduled.\nFor example, this command's \nFoo\n property will be auto-wired to \"bar\" when the command is later executed by the scheduler. \n\n\nschedule\n\n    \n.\nJob\n(\nnew\n \nMyCommand\n()\n \n{\n\n        \nFoo\n \n=\n \nbar\n\n    \n})\n\n    \n.\nEveryFiveMinutes\n();\n\n\n\n\n\n\nIf it is not desirable to auto-wire a property for some reason, simply decorate the property in the command class with the \nInEngine.Core.Scheduling.DoNotAutoWireAttribute\n class. \n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nAbstractCommand\n\n    \n{\n\n\n        [DoNotAutoWire]\n\n        \npublic\n \nstring\n \nFoo\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n        \npublic\n \noverride\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \n// Foo will be null here even if it is initialized before being scheduled. \n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRunning the Scheduler\n\n\nManually from the CLI\n\n\nRunning the scheduler from the CommandLine is useful for debugging or local development:\n\n\ninengine.exe -s\n\n\n\n\n\nIt can also be run on Mac and Linux with Mono via a shell wrapper script:\n\n\n./inengine -s\n\n\n\n\n\nOn Windows as a Service\n\n\nInstalling\n\n\nRun the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. \nThe script needs to be run as an administrator. \nThe script will register the service at the location where the script is run.\n\n\nps Install.ps1\n\n\n\n\n\nUninstalling\n\n\nSimply run the \nUninstall.ps1\n script with elevated permissions to remove the service.\n\n\nps Uninstall.ps1\n\n\n\n\n\nOn Linux with Supervisor\n\n\nSupervisor is a process control system for Linux. \nIt has extensive \ndocumentation\n, but the following should be enough to get started.\n\n\nInstalling Supervisor\n\n\nThis command installs Supervisor on Ubuntu:\n\n\nsudo apt-get install supervisor\n\n\n\n\n\nConfiguring Supervisor\n\n\nSupervisor configuration files are stored in the \n/etc/supervisor/conf.d\n directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called \n/etc/supervisor/conf.d/inengine-scheduler.conf\n. \n\n\n[program:inengine-scheudler]\n\n\nprocess_name\n=\n%(program_name)s_%(process_num)02d\n\n\ndirectory\n=\n/path/to/scheduler\n\n\ncommand\n=\nmono inengine.exe -s\n\n\nautostart\n=\ntrue\n\n\nautorestart\n=\ntrue\n\n\nuser\n=\nInEngine\n\n\nnumprocs\n=\n1\n\n\nredirect_stderr\n=\ntrue\n\n\nstdout_logfile\n=\n./scheduler.log\n\n\n\n\n\n\nStarting Supervisor\n\n\nWhenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.\n\n\nsudo supervisorctl reread\nsudo supervisorctl update\n\n\n\n\n\nNow, simply start the scheduler workers with the \nsupervisorctl\n program:\n\n\nsudo supervisorctl start inengine-scheduler:*\n\n\n\n\n\nIn a Container with Docker\n\n\nInstall \nDocker\n first, then pull the \nethanhann/inengine\n image:\n\n\ndocker pull ethanhann/inengine:latest\n\n\n\n\n\nNow run the scheduler:\n\n\ndocker run --rm inengine -s", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling", 
            "text": "Commands  can be run at certain times on recurring schedules.", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling-a-command", 
            "text": "A job schedule is created by adding a class to your plugin assembly that implements the  InEngine.Core.IJobs  interface.  using   System ;  namespace   MyCommandPlugin  { \n     public   class   Jobs   :   IJobs \n     { \n         public   void   Schedule ( Schedule   schedule ) \n         { \n             // Schedule some jobs \n         } \n     }  }   The InEngine.NET scheduler automatically discovers this class.\nIt will call the Jobs.Schedule method with an initialized  InEngine.Scheduling.Schedule  object.  using   System ;  namespace   MyCommandPlugin  { \n     public   class   Jobs   :   IJobs \n     { \n         public   void   Schedule ( Schedule   schedule ) \n         { \n             /*                * Run MyCommand every five minutes.                */ \n             schedule . Job ( new   MyCommand ()). EveryFiveMinutes (); \n\n             /*                * Run a lambda expression every ten minutes.                */ \n             schedule . Job (()   =   Console . WriteLine ( Hello, world! )). EveryTenMinutes (); \n\n             /*                * Run a parameterless method every five minutes.                */ \n             schedule . Job (()   =   Foo . Bar ). EverySecond (); \n         } \n     }  }   Run a command on a custom cron schedule (in this example every 15 seconds):  schedule . Job ( new   MyCommand ()). Cron ( 15 * * * * ? );   Run a command every second:  schedule . Job ( new   MyCommand ()). EverySecond ();   Run a command every minute:  schedule . Job ( new   MyCommand ()). EveryMinute ();   Run a command every 5 minutes:  schedule . Job ( new   MyCommand ()). EveryFiveMinutes ();   Run a command every 10 minutes:  schedule . Job ( new   MyCommand ()). EveryTenMinutes ();   Run a command every 15 minutes:  schedule . Job ( new   MyCommand ()). EveryFifteenMinutes ();   Run a command every 30 minutes:  schedule . Job ( new   MyCommand ()). EveryThirtyMinutes ();   Run a command hourly:  schedule . Job ( new   MyCommand ()). Hourly ();   Run a command hourly at a certain number of minutes past the hour (27 minutes in this example):  schedule . Job ( new   MyCommand ()). HourlyAt ( 27 );   Run a command daily:  schedule . Job ( new   MyCommand ()). Daily ();   Run a command daily at a specific time (at 10:30pm in this example):  schedule . Job ( new   MyCommand ()). DailyAt ( 22 ,   30 );", 
            "title": "Scheduling a Command"
        }, 
        {
            "location": "/scheduling/#command-state", 
            "text": "Commands can have properties like any C# class.\nWhen running from the command line these properties are usually initialized with command line arguments.\nWhen run by the scheduler, the properties are specified when the command is scheduled.\nFor example, this command's  Foo  property will be auto-wired to \"bar\" when the command is later executed by the scheduler.   schedule \n     . Job ( new   MyCommand ()   { \n         Foo   =   bar \n     }) \n     . EveryFiveMinutes ();   If it is not desirable to auto-wire a property for some reason, simply decorate the property in the command class with the  InEngine.Core.Scheduling.DoNotAutoWireAttribute  class.   using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   AbstractCommand \n     {          [DoNotAutoWire] \n         public   string   Foo   {   get ;   set ;   } \n\n         public   override   void   Run () \n         { \n             // Foo will be null here even if it is initialized before being scheduled.  \n         } \n     }  }", 
            "title": "Command State"
        }, 
        {
            "location": "/scheduling/#running-the-scheduler", 
            "text": "", 
            "title": "Running the Scheduler"
        }, 
        {
            "location": "/scheduling/#manually-from-the-cli", 
            "text": "Running the scheduler from the CommandLine is useful for debugging or local development:  inengine.exe -s  It can also be run on Mac and Linux with Mono via a shell wrapper script:  ./inengine -s", 
            "title": "Manually from the CLI"
        }, 
        {
            "location": "/scheduling/#on-windows-as-a-service", 
            "text": "", 
            "title": "On Windows as a Service"
        }, 
        {
            "location": "/scheduling/#installing", 
            "text": "Run the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. \nThe script needs to be run as an administrator. \nThe script will register the service at the location where the script is run.  ps Install.ps1", 
            "title": "Installing"
        }, 
        {
            "location": "/scheduling/#uninstalling", 
            "text": "Simply run the  Uninstall.ps1  script with elevated permissions to remove the service.  ps Uninstall.ps1", 
            "title": "Uninstalling"
        }, 
        {
            "location": "/scheduling/#on-linux-with-supervisor", 
            "text": "Supervisor is a process control system for Linux. \nIt has extensive  documentation , but the following should be enough to get started.", 
            "title": "On Linux with Supervisor"
        }, 
        {
            "location": "/scheduling/#installing-supervisor", 
            "text": "This command installs Supervisor on Ubuntu:  sudo apt-get install supervisor", 
            "title": "Installing Supervisor"
        }, 
        {
            "location": "/scheduling/#configuring-supervisor", 
            "text": "Supervisor configuration files are stored in the  /etc/supervisor/conf.d  directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called  /etc/supervisor/conf.d/inengine-scheduler.conf .   [program:inengine-scheudler]  process_name = %(program_name)s_%(process_num)02d  directory = /path/to/scheduler  command = mono inengine.exe -s  autostart = true  autorestart = true  user = InEngine  numprocs = 1  redirect_stderr = true  stdout_logfile = ./scheduler.log", 
            "title": "Configuring Supervisor"
        }, 
        {
            "location": "/scheduling/#starting-supervisor", 
            "text": "Whenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.  sudo supervisorctl reread\nsudo supervisorctl update  Now, simply start the scheduler workers with the  supervisorctl  program:  sudo supervisorctl start inengine-scheduler:*", 
            "title": "Starting Supervisor"
        }, 
        {
            "location": "/scheduling/#in-a-container-with-docker", 
            "text": "Install  Docker  first, then pull the  ethanhann/inengine  image:  docker pull ethanhann/inengine:latest  Now run the scheduler:  docker run --rm inengine -s", 
            "title": "In a Container with Docker"
        }, 
        {
            "location": "/queuing/", 
            "text": "Queuing\n\n\nInEngine.NET's queue functionality allows for commands to be run in the background with a simple publish/consume model. \n\n\nQueue Drivers\n\n\nTo make use of queue features, a queue driver must be specified in \nappsettings.json\n.\nThese are the available drivers...\n\n\nFile\n\n\nThe file driver writes queued messages to the file system. \nIt is useful for testing and development, but probably not suitable for production.\n\n\nRedis\n\n\nRedis is suitable for production use. \nInEngine.NET utilizes Redis' durable queue features which mean messages will not be lost if InEngine.NET unexpectedly fails. \n\n\nRedis can be installed on Ubuntu with this command:\n\n\nsudo apt-get install redis-server\n\n\n\n\n\nStart Redis with this command:\n\n\nsudo service redis start\n\n\n\n\n\n\nIt is highly recommended to \nset a password\n for Redis.\n\n\n\n\nSync\n\n\nThe sync driver causes the publish command to run a published command synchronously.\nAll other queue commands and methods are not supported and will throw an exception if called.\nThis driver can be useful for plugin development and testing.\n\n\nPublishing Commands\n\n\nWith C# Classes\n\n\nCommands\n can be published programmatically with the \nInEngine.Core.Queuing.Queue\n class:\n\n\nQueue\n.\nMake\n().\nPublish\n(\nnew\n \nMyCommand\n());\n\n\n\n\n\n\nOr publish to the secondary queue by passing true to the Make method:\n\n\nQueue\n.\nMake\n(\ntrue\n).\nPublish\n(\nnew\n \nMyCommand\n());\n\n\n\n\n\n\n\n\nDo I have to use Queue.Make()?\n\n\nQueue.Make() is a factory method that autoloads the queue settings from appsettings.json, creates the appropriate queue driver, and returns an instance of Queue.\nYou can create your own Queue object an initialize it if you want.\nAt the very least you can assign the object returned by Queue.Make() to a local variable or load it into a DI container for later use.\n\n\n\n\nWith Lambda Expressions\n\n\nLambda expressions, aka anonymous functions, can be queued.\nThe disadvantage to queuing lambdas is that the helpful functionality available in \nInEngine.Core.AbstractCommand\n is not available.  \n\n\nThis is how you queue a lambda:\n\n\nQueue\n.\nMake\n().\nPublish\n(()\n \n=\n \nConsole\n.\nWriteLine\n(\nHello, world!\n));\n\n\n\n\n\n\nHere is a neat shortcut for commands without parameters:\n\n\nQueue\n.\nMake\n().\nPublish\n(()\n \n=\n \nFoo\n.\nBar\n());\n\n\n// Can be rewritten as...\n\n\nQueue\n.\nMake\n().\nPublish\n(\nFoo\n.\nBar\n);\n\n\n\n\n\n\nSequentially In a Chain\n\n\nChained commands run in the order specified.\nThis is useful for when order matters.\n\n\nAlso, if one command in the chain fails, then subsequent commands are not run at all.\nThis affords the opportunity to add additional code that records which command failed, then resuming the command chain where it left off.\n\n\nHere is a an example of how to chain an imaginary file transfer command together:\n\n\nSubject\n.\nPublish\n(\nnew\n[]\n \n{\n\n    \nnew\n \nMyFileTransfer\n(\nfilePath1\n),\n\n    \nnew\n \nMyFileTransfer\n(\nfilePath2\n),\n\n    \nnew\n \nMyFileTransfer\n(\nfilePath3\n),\n\n\n});\n\n\n\n\n\n\nSubject\n.\nPublish\n(\nnew\n \nList\nAbstractCommand\n()\n \n{\n\n    \nnew\n \nAlwaysSucceed\n(),\n\n    \nnew\n \nEcho\n()\n \n{\n \nVerbatimText\n \n=\n \nHello, world!\n},\n\n\n});\n\n\n\n\n\n\nFrom the Command Line\n\n\nCommands can be published from the command line as well.\nNote that all queue commands reside in the \nInEngine.Core\n plugin.\nThis is an example of how to publish a command from the CLI by specifying the command's plugin, class name, and arguments:\n\n\ninengine.exe -pInEngine.Core queue:publish --command-plugin\n=\nMyCommandPlugin.dll --command-class\n=\nMyCommand --args \ntext=bar\n\n\n\n\n\n\nThere is an \"Echo\" command in the \nInEngine.Core\n package. It is useful for end-to-end testing with the queue feature.\n\n\ninengine.exe -pInEngine.Core queue:publish --command-plugin\n=\nInEngine.Core.dll --command-class\n=\nInEngine.Core.Commands.Echo --args \ntext=foo\n\n\n\n\n\n\nThe command verb can also be specified instead of the full class name:\n\n\ninengine.exe -pInEngine.Core queue:publish --command-plugin\n=\nInEngine.Core.dll --command-verb\n=\necho--args \ntext=foo\n\n\n\n\n\n\nConsuming Commands\n\n\nFrom Code\n\n\nConsuming a command is also accomplished with the Queue class:\n\n\nQueue\n.\nMake\n().\nConsume\n();\n\n\n\n\n\n\nThe make method takes an optional second argument to indicate if the secondary queue should be used instead of the primary queue.\n\n\n// Uses secondary queue.\n\n\nQueue\n.\nMake\n(\ntrue\n).\nConsume\n();\n\n\n\n\n\n\nCommands can be consumed from the command line as well with this simple command:\n\n\nFrom the Command Line\n\n\ninengine.exe -pInEngine.Core queue:consume\n\n\n\n\n\nUse the \n--secondary\n argument to consume the secondary queue instead of the primary queue:\n\n\ninengine.exe -pInEngine.Core queue:consume --secondary\n\n\n\n\n\nWith the Scheduler\n\n\nThe InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of \nways to run the scheduler\n.\n\n\nExamining the Queue\n\n\nViewing Queue Lengths\n\n\nThe \nqueue:length\n command shows a quick summary of pending, in-progress, and failed commands in the primary and secondary queues:\n\n\ninengine.exe -pInEngine.Core queue:length\n\n\n\n\n\nPeek at Queued Commands\n\n\nThe \nqueue:peek\n command allows for queued commands to be inspected:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --in-progress --failed\n\n\n\n\n\nIt is of course possible to peek in the secondary queues:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --secondary\n\n\n\n\n\nQueued commands can be viewed in JSON which maybe useful for debugging:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --json\n\n\n\n\n\nBy default, up to the first 10 messages will be retrieved, but the range is configurable:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --to\n=\n100\n\n\n\n\n\n\nA slice of the queue can be retrieved using the from argument.\nFor example, this queue:peek call retrieves the 100-200 queued commands:\n\n\ninengine.exe -pInEngine.Core queue:peek --pending --from\n=\n100\n --to\n=\n200\n\n\n\n\n\n\nHandling Failed Commands\n\n\nCommands that throw an exception are put in a special \"failed\" queue. \nThey can be republished with the \nqueue:republish\n command:\n\n\ninengine.exe -pInEngine.Core queue:republish\n\n\n\n\n\nFailed secondary queue commands can be republished as well:\n\n\ninengine.exe -pInEngine.Core queue:republish --secondary\n\n\n\n\n\nBy default, only 100 failed commands are republished at a time.\nThe is configurable:\n\n\ninengine.exe -pInEngine.Core queue:republish --limit\n=\n1000\n\n\n\n\n\n\nPrimary and Secondary Queue\n\n\nOther than the fact that the primary queue is used by default, there is no difference between the primary and secondary queues. \nHowever, it is often desirable to use two queues. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.\n\n\nWhat about 3, 4, or 900 queues? Managing numerous queues gets to be a pain and, practically speaking, is probably unnecessary.\nIf it is desirable, different \nconfiguration files\n can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it with the -c argument:\n\n\ninengine.exe -cMyCustomSettingsFile.json -pInEngine.Core queue:consume\n\n\n\n\n\nMessage Compression\n\n\nMessages can be compressed when saved in the queue. \nIt is important to understand the trade-offs of this feature before enabling it.\nIf the queued commands are too small to benefit from being compressed, then compressing them wastes resources.\nCompressing messages takes more CPU resources and might negatively impact queue throughput if the queued commands do not have a lot of internal state.\n\n\nIf the commands have a lot of internal state, then this feature will reduce the queue's memory consumption.\nAlso, in a high-throughput scenario, where network bandwidth is limited, this feature can greatly reduce the amount of bandwidth used.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#queuing", 
            "text": "InEngine.NET's queue functionality allows for commands to be run in the background with a simple publish/consume model.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#queue-drivers", 
            "text": "To make use of queue features, a queue driver must be specified in  appsettings.json .\nThese are the available drivers...", 
            "title": "Queue Drivers"
        }, 
        {
            "location": "/queuing/#file", 
            "text": "The file driver writes queued messages to the file system. \nIt is useful for testing and development, but probably not suitable for production.", 
            "title": "File"
        }, 
        {
            "location": "/queuing/#redis", 
            "text": "Redis is suitable for production use. \nInEngine.NET utilizes Redis' durable queue features which mean messages will not be lost if InEngine.NET unexpectedly fails.   Redis can be installed on Ubuntu with this command:  sudo apt-get install redis-server  Start Redis with this command:  sudo service redis start  \nIt is highly recommended to  set a password  for Redis.", 
            "title": "Redis"
        }, 
        {
            "location": "/queuing/#sync", 
            "text": "The sync driver causes the publish command to run a published command synchronously.\nAll other queue commands and methods are not supported and will throw an exception if called.\nThis driver can be useful for plugin development and testing.", 
            "title": "Sync"
        }, 
        {
            "location": "/queuing/#publishing-commands", 
            "text": "", 
            "title": "Publishing Commands"
        }, 
        {
            "location": "/queuing/#with-c-classes", 
            "text": "Commands  can be published programmatically with the  InEngine.Core.Queuing.Queue  class:  Queue . Make (). Publish ( new   MyCommand ());   Or publish to the secondary queue by passing true to the Make method:  Queue . Make ( true ). Publish ( new   MyCommand ());    Do I have to use Queue.Make()?  Queue.Make() is a factory method that autoloads the queue settings from appsettings.json, creates the appropriate queue driver, and returns an instance of Queue.\nYou can create your own Queue object an initialize it if you want.\nAt the very least you can assign the object returned by Queue.Make() to a local variable or load it into a DI container for later use.", 
            "title": "With C# Classes"
        }, 
        {
            "location": "/queuing/#with-lambda-expressions", 
            "text": "Lambda expressions, aka anonymous functions, can be queued.\nThe disadvantage to queuing lambdas is that the helpful functionality available in  InEngine.Core.AbstractCommand  is not available.    This is how you queue a lambda:  Queue . Make (). Publish (()   =   Console . WriteLine ( Hello, world! ));   Here is a neat shortcut for commands without parameters:  Queue . Make (). Publish (()   =   Foo . Bar ());  // Can be rewritten as...  Queue . Make (). Publish ( Foo . Bar );", 
            "title": "With Lambda Expressions"
        }, 
        {
            "location": "/queuing/#sequentially-in-a-chain", 
            "text": "Chained commands run in the order specified.\nThis is useful for when order matters.  Also, if one command in the chain fails, then subsequent commands are not run at all.\nThis affords the opportunity to add additional code that records which command failed, then resuming the command chain where it left off.  Here is a an example of how to chain an imaginary file transfer command together:  Subject . Publish ( new []   { \n     new   MyFileTransfer ( filePath1 ), \n     new   MyFileTransfer ( filePath2 ), \n     new   MyFileTransfer ( filePath3 ),  });   Subject . Publish ( new   List AbstractCommand ()   { \n     new   AlwaysSucceed (), \n     new   Echo ()   {   VerbatimText   =   Hello, world! },  });", 
            "title": "Sequentially In a Chain"
        }, 
        {
            "location": "/queuing/#from-the-command-line", 
            "text": "Commands can be published from the command line as well.\nNote that all queue commands reside in the  InEngine.Core  plugin.\nThis is an example of how to publish a command from the CLI by specifying the command's plugin, class name, and arguments:  inengine.exe -pInEngine.Core queue:publish --command-plugin = MyCommandPlugin.dll --command-class = MyCommand --args  text=bar   There is an \"Echo\" command in the  InEngine.Core  package. It is useful for end-to-end testing with the queue feature.  inengine.exe -pInEngine.Core queue:publish --command-plugin = InEngine.Core.dll --command-class = InEngine.Core.Commands.Echo --args  text=foo   The command verb can also be specified instead of the full class name:  inengine.exe -pInEngine.Core queue:publish --command-plugin = InEngine.Core.dll --command-verb = echo--args  text=foo", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#consuming-commands", 
            "text": "", 
            "title": "Consuming Commands"
        }, 
        {
            "location": "/queuing/#from-code", 
            "text": "Consuming a command is also accomplished with the Queue class:  Queue . Make (). Consume ();   The make method takes an optional second argument to indicate if the secondary queue should be used instead of the primary queue.  // Uses secondary queue.  Queue . Make ( true ). Consume ();   Commands can be consumed from the command line as well with this simple command:", 
            "title": "From Code"
        }, 
        {
            "location": "/queuing/#from-the-command-line_1", 
            "text": "inengine.exe -pInEngine.Core queue:consume  Use the  --secondary  argument to consume the secondary queue instead of the primary queue:  inengine.exe -pInEngine.Core queue:consume --secondary", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#with-the-scheduler", 
            "text": "The InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of  ways to run the scheduler .", 
            "title": "With the Scheduler"
        }, 
        {
            "location": "/queuing/#examining-the-queue", 
            "text": "", 
            "title": "Examining the Queue"
        }, 
        {
            "location": "/queuing/#viewing-queue-lengths", 
            "text": "The  queue:length  command shows a quick summary of pending, in-progress, and failed commands in the primary and secondary queues:  inengine.exe -pInEngine.Core queue:length", 
            "title": "Viewing Queue Lengths"
        }, 
        {
            "location": "/queuing/#peek-at-queued-commands", 
            "text": "The  queue:peek  command allows for queued commands to be inspected:  inengine.exe -pInEngine.Core queue:peek --pending --in-progress --failed  It is of course possible to peek in the secondary queues:  inengine.exe -pInEngine.Core queue:peek --pending --secondary  Queued commands can be viewed in JSON which maybe useful for debugging:  inengine.exe -pInEngine.Core queue:peek --pending --json  By default, up to the first 10 messages will be retrieved, but the range is configurable:  inengine.exe -pInEngine.Core queue:peek --pending --to = 100   A slice of the queue can be retrieved using the from argument.\nFor example, this queue:peek call retrieves the 100-200 queued commands:  inengine.exe -pInEngine.Core queue:peek --pending --from = 100  --to = 200", 
            "title": "Peek at Queued Commands"
        }, 
        {
            "location": "/queuing/#handling-failed-commands", 
            "text": "Commands that throw an exception are put in a special \"failed\" queue. \nThey can be republished with the  queue:republish  command:  inengine.exe -pInEngine.Core queue:republish  Failed secondary queue commands can be republished as well:  inengine.exe -pInEngine.Core queue:republish --secondary  By default, only 100 failed commands are republished at a time.\nThe is configurable:  inengine.exe -pInEngine.Core queue:republish --limit = 1000", 
            "title": "Handling Failed Commands"
        }, 
        {
            "location": "/queuing/#primary-and-secondary-queue", 
            "text": "Other than the fact that the primary queue is used by default, there is no difference between the primary and secondary queues. \nHowever, it is often desirable to use two queues. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.  What about 3, 4, or 900 queues? Managing numerous queues gets to be a pain and, practically speaking, is probably unnecessary.\nIf it is desirable, different  configuration files  can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it with the -c argument:  inengine.exe -cMyCustomSettingsFile.json -pInEngine.Core queue:consume", 
            "title": "Primary and Secondary Queue"
        }, 
        {
            "location": "/queuing/#message-compression", 
            "text": "Messages can be compressed when saved in the queue. \nIt is important to understand the trade-offs of this feature before enabling it.\nIf the queued commands are too small to benefit from being compressed, then compressing them wastes resources.\nCompressing messages takes more CPU resources and might negatively impact queue throughput if the queued commands do not have a lot of internal state.  If the commands have a lot of internal state, then this feature will reduce the queue's memory consumption.\nAlso, in a high-throughput scenario, where network bandwidth is limited, this feature can greatly reduce the amount of bandwidth used.", 
            "title": "Message Compression"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nConfiguration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution. The -c, --configuration argument can also be used to specify an alternate configuration file.\n\n\n{\n\n  \nInEngine\n:\n \n{\n\n    \nPlugins\n:\n \n[\n\n      \npath/to/MyCommandPlugin\n\n    \n],\n\n    \nQueue\n:\n \n{\n\n      \nUseCompression\n:\n \nfalse\n,\n\n      \nPrimaryQueueConsumers\n:\n  \n16\n,\n\n      \nSecondaryQueueConsumers\n:\n \n4\n,\n\n      \nQueueDriver\n:\n \nredis\n,\n\n      \nQueueName\n:\n \nInEngineQueue\n,\n\n      \nRedisHost\n:\n \nlocalhost\n,\n\n      \nRedisPort\n:\n \n6379\n,\n\n      \nRedisDb\n:\n \n0\n,\n\n      \nRedisPassword\n:\n \n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nTop-level Settings\n\n\n\n\n\n\n\n\nSetting\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPlugins\n\n\narray of strings\n\n\nA list of paths of plugin assemblies, with \".dll\" omitted from the assembly name.\n\n\n\n\n\n\n\n\nQueue Settings\n\n\n\n\n\n\n\n\nSetting\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUseCompression\n\n\nbool\n\n\nA situation performance optimization that compresses queued messages.\n\n\n\n\n\n\nPrimaryQueueConsumers\n\n\nstring\n\n\nThe number of consumers to schedule for the secondary queue.\n\n\n\n\n\n\nSecondaryQueueConsumers\n\n\nstring\n\n\nThe number of consumers to schedule for the secondary queue.\n\n\n\n\n\n\nQueueDriver\n\n\nstring\n\n\nThe driver to use to interact with a queue data store.\n\n\n\n\n\n\nQueueName\n\n\nstring\n\n\nThe base name of the queue, used to form the Redis Queue keys.\n\n\n\n\n\n\nRedisHost\n\n\nstring\n\n\nThe Redis hostname to connect to.\n\n\n\n\n\n\nRedisPort\n\n\ninteger\n\n\nRedis's port.\n\n\n\n\n\n\nRedisDb\n\n\ninteger\n\n\nThe Redis database - 0-15\n\n\n\n\n\n\nRedisPassword\n\n\nstring\n\n\nThe Redis auth password", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "Configuration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution. The -c, --configuration argument can also be used to specify an alternate configuration file.  { \n   InEngine :   { \n     Plugins :   [ \n       path/to/MyCommandPlugin \n     ], \n     Queue :   { \n       UseCompression :   false , \n       PrimaryQueueConsumers :    16 , \n       SecondaryQueueConsumers :   4 , \n       QueueDriver :   redis , \n       QueueName :   InEngineQueue , \n       RedisHost :   localhost , \n       RedisPort :   6379 , \n       RedisDb :   0 , \n       RedisPassword :   \n     } \n   }  }", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#top-level-settings", 
            "text": "Setting  Type  Description      Plugins  array of strings  A list of paths of plugin assemblies, with \".dll\" omitted from the assembly name.", 
            "title": "Top-level Settings"
        }, 
        {
            "location": "/configuration/#queue-settings", 
            "text": "Setting  Type  Description      UseCompression  bool  A situation performance optimization that compresses queued messages.    PrimaryQueueConsumers  string  The number of consumers to schedule for the secondary queue.    SecondaryQueueConsumers  string  The number of consumers to schedule for the secondary queue.    QueueDriver  string  The driver to use to interact with a queue data store.    QueueName  string  The base name of the queue, used to form the Redis Queue keys.    RedisHost  string  The Redis hostname to connect to.    RedisPort  integer  Redis's port.    RedisDb  integer  The Redis database - 0-15    RedisPassword  string  The Redis auth password", 
            "title": "Queue Settings"
        }
    ]
}