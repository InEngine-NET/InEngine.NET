{
    "docs": [
        {
            "location": "/", 
            "text": "InEngine.NET is a plugin-based software application that allows \ncommands\n to be \nqueued\n, \nscheduled\n, and run directly.\n\n\nHow does it work?\n\n\nInEngine.NET uses a plugin system to dynamically load .NET assemblies and execute code. \nIt also has a built-in command for launching external non-.NET programs.\n\n\nGet started by pulling the binaries from the \nlatest release\n on GitHub.\n\n\nThen run the \necho\n command from the core plugin:\n\n\ninengine.exe \necho\n --text\nHello, world\n\n\n\n\n\n\nOr if you're a Linux or Mac OS X fan (like me!), use the \ninengine\n shell script (\nMono\n is required):\n\n\ninengine \necho\n --text\nHello, world\n\n\n\n\n\n\nInstead of downloading binaries and runtimes, you can pull the latest Docker image:\n\n\ndocker pull ethanhann/inengine:latest\n\n\n\n\n\nNow run a command in a container:\n\n\ndocker run --rm inengine \necho\n --text\nHello, world\n\n\n\n\n\n\nHow does queueing work?\n\n\nWant to queue our example echo command to run in the background or possibly on another server?\n\n\nUse the core plugin's \nqueue:publish\n command:\n\n\ninengine.exe queue:publish --plugin\n=\nInEngine.Core --command\n=\necho\n --args \ntext=Hello, world\n\n\n\n\n\n\nHow do we consume that queued echo command?\n\n\nUse the core plugin's \nqueue:consume\n command:\n\n\ninengine.exe queue:consume\n\n\n\n\n\nHow do I run non-.NET commands?\n\n\nThere is a special \nexec\n command in the core plugin that allows for the execution of any program you can run at the command line. \n\n\nFor example, create a python script called \nhelloworld.py\n, make it executable, and add this to it:\n\n\n#!/usr/bin/env python\n\n\n\nprint\n \nHello, world!\n\n\n\n\n\n\nWhitelist the \"helloworld\" executable in the \nappsettings.json\n file:\n\n\n{\n\n  \nInEngine\n:\n \n{\n\n    \n//\n \n...\n\n    \nExecWhitelist\n:\n \n{\n\n      \nhelloworld\n:\n \n/path/to/helloworld.py\n\n    \n}\n\n    \n//\n \n...\n\n  \n}\n\n\n}\n\n\n\n\n\n\nNow execute it with the \nexec\n command:\n\n\ninengine \nexec\n --executable\n=\nhelloworld\n\n\n\n\n\n\nWhy would you want to do this?\nIt opens up the possibility of running shell scripts, ETLs, Java programs, etc. in the background or on a schedule. \n\n\nThe example python script can be queued:\n\n\ninengine queue:publish --plugin\n=\nInEngine.Core --command\n=\nexec\n --args\n=\nexecutable=helloworld", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#how-does-it-work", 
            "text": "InEngine.NET uses a plugin system to dynamically load .NET assemblies and execute code. \nIt also has a built-in command for launching external non-.NET programs.  Get started by pulling the binaries from the  latest release  on GitHub.  Then run the  echo  command from the core plugin:  inengine.exe  echo  --text Hello, world   Or if you're a Linux or Mac OS X fan (like me!), use the  inengine  shell script ( Mono  is required):  inengine  echo  --text Hello, world   Instead of downloading binaries and runtimes, you can pull the latest Docker image:  docker pull ethanhann/inengine:latest  Now run a command in a container:  docker run --rm inengine  echo  --text Hello, world", 
            "title": "How does it work?"
        }, 
        {
            "location": "/#how-does-queueing-work", 
            "text": "Want to queue our example echo command to run in the background or possibly on another server?  Use the core plugin's  queue:publish  command:  inengine.exe queue:publish --plugin = InEngine.Core --command = echo  --args  text=Hello, world   How do we consume that queued echo command?  Use the core plugin's  queue:consume  command:  inengine.exe queue:consume", 
            "title": "How does queueing work?"
        }, 
        {
            "location": "/#how-do-i-run-non-net-commands", 
            "text": "There is a special  exec  command in the core plugin that allows for the execution of any program you can run at the command line.   For example, create a python script called  helloworld.py , make it executable, and add this to it:  #!/usr/bin/env python  print   Hello, world!   Whitelist the \"helloworld\" executable in the  appsettings.json  file:  { \n   InEngine :   { \n     //   ... \n     ExecWhitelist :   { \n       helloworld :   /path/to/helloworld.py \n     } \n     //   ... \n   }  }   Now execute it with the  exec  command:  inengine  exec  --executable = helloworld   Why would you want to do this?\nIt opens up the possibility of running shell scripts, ETLs, Java programs, etc. in the background or on a schedule.   The example python script can be queued:  inengine queue:publish --plugin = InEngine.Core --command = exec  --args = executable=helloworld", 
            "title": "How do I run non-.NET commands?"
        }, 
        {
            "location": "/license/", 
            "text": "The MIT License (MIT)\n\n\nCopyright (c) 2017 Ethan Hann\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/commands/", 
            "text": "Commands\n\n\nCommands can be C# classes, lambda expressions, or CLI programs.\nThey can be queued, scheduled, or run from the command line.\n\n\nCreate a Command\n\n\nThe InEngine.Core package is required to create a C# class command. \nInstall it in a Visual Studio project.\n\n\nPackage Manager\n\n\nInstall-Package InEngine.Core\n\n\n\n\n\nNuget CLI\n\n\nnuget install InEgine.Core\n\n\n\n\n\n.NET CLI\n\n\ndotnet add package InEngine.Core\n\n\n\n\n\nPaket CLI\n\n\npaket add InEngine.Core\n\n\n\n\n\nTo create a class command, extend the \nInEngine.Core.AbstractCommand\n class.\nMinimally, the Run method should be overridden.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nAbstractCommand\n\n    \n{\n\n        \npublic\n \noverride\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \nConsole\n.\nWriteLine\n(\nHello, world!\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRun a Command\n\n\nCreate a class that extends \nInEngine.Core.AbstractPlugin\n in the same assembly as the command class.\nAdd a VerbOptions attribute, from the \nCommandLine\n namespace, that defines the name of the command. \n\n\nThis class registers a command in the MyPlugin assembly called \"mycommand\":\n\n\nusing\n \nCommandLine\n;\n\n\nusing\n \nCommandLine.Text\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyPlugin\n \n:\n \nAbstractPlugin\n\n    \n{\n\n\n        [VerbOption(\nmycommand\n, HelpText=\nMy example command.\n)]\n\n        \npublic\n \nMyCommand\n \nMyCommand\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDownload the InEngine binary distribution, from the \nGitHub Releases\n page, that matches the version of the InEngine.Core package you included.\n\n\nCopy your project's DLLs into the Plugins subdirectory included in the binary distribution. \nAdd your plugin to the \"Plugins\" list in \nappsettings.config\n at the root of the binary distribution.\n\n\nRun your command:\n\n\ninengine.exe mycommand\n\n\n\n\n\nWriting Output\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides some helper functions to output text to the console, for example:\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \nLine\n(\nDisplay some information\n);\n\n\n}\n\n\n\n\n\n\nAll of these commands append a newline to the end of the specified text:\n\n\nLine\n(\nThis is some text\n);\n                  \n// Text color is white\n\n\nInfo\n(\nSomething good happened\n);\n            \n// Text color is green\n\n\nWarning\n(\nSomething not so good happened\n);\n  \n// Text color is yellow\n\n\nError\n(\nSomething bad happened\n);\n            \n// Text color is red\n\n\n\n\n\n\nThese commands are similar, but they do not append a newline:\n\n\nText\n(\nThis is some text\n);\n                      \n// Text color is white\n\n\nInfoText\n(\nSomething good happened\n);\n            \n// Text color is green\n\n\nWarningText\n(\nSomething not so good happened\n);\n  \n// Text color is yellow\n\n\nErrorText\n(\nSomething bad happened\n);\n            \n// Text color is red\n\n\n\n\n\n\nYou can also display newlines:\n\n\nNewline\n();\n      \n// 1 newline\n\n\nNewline\n(\n5\n);\n     \n// 5 newlines\n\n\nNewline\n(\n10\n);\n    \n// 10 newlines\n\n\n\n\n\n\nThe methods can be chained together:\n\n\nInfoText\n(\nYou have this many things: \n)\n\n    \n.\nLine\n(\n23\n)\n\n    \n.\nNewLine\n(\n2\n)\n\n    \n.\nInfoText\n(\nYou have this many other things: \n)\n\n    \n.\nLine\n(\n34\n)\n\n    \n.\nNewLine\n(\n2\n);\n \n\n\n\n\n\nProgress Bar\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides a ProgressBar property to show command progress in a terminal.\nThis is how it is used:\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \n// Define the ticks (aka steps) for the command...\n\n    \nvar\n \nmaxTicks\n \n=\n \n100000\n;\n\n    \nSetProgressBarMaxTicks\n(\nmaxTicks\n);\n\n\n    \n// Do some work...\n\n    \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \nmaxTicks\n;\ni\n++)\n\n    \n{\n\n        \n// Update the command\ns progress\n\n        \nUpdateProgress\n(\ni\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRunning non-.NET Commands\n\n\nIt is not necessary to create C# classes to utilize InEngine.NET.\nArbitrary external programs can be run, with an optional argument list, by leveraging the InEngine.Core plugin's \nexec\n command.\n\n\nFor example, create a python script called \nhelloworld.py\n, make it executable, and add this to it:\n\n\n#!/usr/bin/env python\n\n\n\nprint\n \nHello, world!\n\n\n\n\n\n\nWhitelist the helloworld.py script in the \nappsettings.json\n file:\n\n\n{\n\n  \nInEngine\n:\n \n{\n\n    \n//\n \n...\n\n    \nExecWhitelist\n:\n \n{\n\n      \nhelloworld\n:\n \n/path/to/helloworld.py\n\n    \n}\n\n    \n//\n \n...\n\n  \n}\n\n\n}\n\n\n\n\n\n\nNow execute it with the \nexec\n command:\n\n\ninengine \nexec\n --executable\n=\nhelloworld\n\n\n\n\n\n\nIf an external executable requires arguments, use the \n--args\n argument:\n\n\ninengine \nexec\n --executable\n=\nfoo\n --args\n=\n--version\n\n\n\n\n\n\nView Commands\n\n\nRun inengine.exe with no arguments to see a list of commands:\n\n\ninengine.exe\n\n\n\n\n\n\n\n\n\nInEngine.Core is a Plugin\n\n\nThe \nInEngine.Core\n library is itself a plugin that contains queueing, scheduling, and other commands. \n\n\n\n\nView a Command's Help Text\n\n\nRun the command with the -h or --help arguments to see help text.\n\n\nThis command prints the publish command's help text, from the core plugin:\n\n\ninengine.exe queue:publish -h\n\n\n\n\n\nThe \nInEngine.Core\n plugin's command to clear the InEngine.NET queues produces this help message. \n\n\nInEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  --plugin            Required. The name of a command plugin file, e.g. \n                      InEngine.Core\n\n  --command           A command name, e.g. echo\n\n  --class             A command class, e.g. \n                      InEngine.Core.Commands.AlwaysSucceed. Takes precedence \n                      over --command if both are specified.\n\n  --args              An optional list of arguments to publish with the \n                      command.\n\n  --secondary         (Default: False) Publish the command to the secondary \n                      queue.", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#commands", 
            "text": "Commands can be C# classes, lambda expressions, or CLI programs.\nThey can be queued, scheduled, or run from the command line.", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#create-a-command", 
            "text": "The InEngine.Core package is required to create a C# class command. \nInstall it in a Visual Studio project.  Package Manager  Install-Package InEngine.Core  Nuget CLI  nuget install InEgine.Core  .NET CLI  dotnet add package InEngine.Core  Paket CLI  paket add InEngine.Core  To create a class command, extend the  InEngine.Core.AbstractCommand  class.\nMinimally, the Run method should be overridden.  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   AbstractCommand \n     { \n         public   override   void   Run () \n         { \n             Console . WriteLine ( Hello, world! ); \n         } \n     }  }", 
            "title": "Create a Command"
        }, 
        {
            "location": "/commands/#run-a-command", 
            "text": "Create a class that extends  InEngine.Core.AbstractPlugin  in the same assembly as the command class.\nAdd a VerbOptions attribute, from the  CommandLine  namespace, that defines the name of the command.   This class registers a command in the MyPlugin assembly called \"mycommand\":  using   CommandLine ;  using   CommandLine.Text ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyPlugin   :   AbstractPlugin \n     {          [VerbOption( mycommand , HelpText= My example command. )] \n         public   MyCommand   MyCommand   {   get ;   set ;   } \n     }  }   Download the InEngine binary distribution, from the  GitHub Releases  page, that matches the version of the InEngine.Core package you included.  Copy your project's DLLs into the Plugins subdirectory included in the binary distribution. \nAdd your plugin to the \"Plugins\" list in  appsettings.config  at the root of the binary distribution.  Run your command:  inengine.exe mycommand", 
            "title": "Run a Command"
        }, 
        {
            "location": "/commands/#writing-output", 
            "text": "The  InEngine.Core.AbstractCommand  class provides some helper functions to output text to the console, for example:  public   override   void   Run ()  { \n     Line ( Display some information );  }   All of these commands append a newline to the end of the specified text:  Line ( This is some text );                    // Text color is white  Info ( Something good happened );              // Text color is green  Warning ( Something not so good happened );    // Text color is yellow  Error ( Something bad happened );              // Text color is red   These commands are similar, but they do not append a newline:  Text ( This is some text );                        // Text color is white  InfoText ( Something good happened );              // Text color is green  WarningText ( Something not so good happened );    // Text color is yellow  ErrorText ( Something bad happened );              // Text color is red   You can also display newlines:  Newline ();        // 1 newline  Newline ( 5 );       // 5 newlines  Newline ( 10 );      // 10 newlines   The methods can be chained together:  InfoText ( You have this many things:  ) \n     . Line ( 23 ) \n     . NewLine ( 2 ) \n     . InfoText ( You have this many other things:  ) \n     . Line ( 34 ) \n     . NewLine ( 2 );", 
            "title": "Writing Output"
        }, 
        {
            "location": "/commands/#progress-bar", 
            "text": "The  InEngine.Core.AbstractCommand  class provides a ProgressBar property to show command progress in a terminal.\nThis is how it is used:  public   override   void   Run ()  { \n     // Define the ticks (aka steps) for the command... \n     var   maxTicks   =   100000 ; \n     SetProgressBarMaxTicks ( maxTicks ); \n\n     // Do some work... \n     for   ( var   i   =   0 ;   i   =   maxTicks ; i ++) \n     { \n         // Update the command s progress \n         UpdateProgress ( i ); \n     }  }", 
            "title": "Progress Bar"
        }, 
        {
            "location": "/commands/#running-non-net-commands", 
            "text": "It is not necessary to create C# classes to utilize InEngine.NET.\nArbitrary external programs can be run, with an optional argument list, by leveraging the InEngine.Core plugin's  exec  command.  For example, create a python script called  helloworld.py , make it executable, and add this to it:  #!/usr/bin/env python  print   Hello, world!   Whitelist the helloworld.py script in the  appsettings.json  file:  { \n   InEngine :   { \n     //   ... \n     ExecWhitelist :   { \n       helloworld :   /path/to/helloworld.py \n     } \n     //   ... \n   }  }   Now execute it with the  exec  command:  inengine  exec  --executable = helloworld   If an external executable requires arguments, use the  --args  argument:  inengine  exec  --executable = foo  --args = --version", 
            "title": "Running non-.NET Commands"
        }, 
        {
            "location": "/commands/#view-commands", 
            "text": "Run inengine.exe with no arguments to see a list of commands:  inengine.exe    InEngine.Core is a Plugin  The  InEngine.Core  library is itself a plugin that contains queueing, scheduling, and other commands.", 
            "title": "View Commands"
        }, 
        {
            "location": "/commands/#view-a-commands-help-text", 
            "text": "Run the command with the -h or --help arguments to see help text.  This command prints the publish command's help text, from the core plugin:  inengine.exe queue:publish -h  The  InEngine.Core  plugin's command to clear the InEngine.NET queues produces this help message.   InEngine 3.x\nCopyright \u00a9 2017 Ethan Hann\n\n  --plugin            Required. The name of a command plugin file, e.g. \n                      InEngine.Core\n\n  --command           A command name, e.g. echo\n\n  --class             A command class, e.g. \n                      InEngine.Core.Commands.AlwaysSucceed. Takes precedence \n                      over --command if both are specified.\n\n  --args              An optional list of arguments to publish with the \n                      command.\n\n  --secondary         (Default: False) Publish the command to the secondary \n                      queue.", 
            "title": "View a Command's Help Text"
        }, 
        {
            "location": "/scheduling/", 
            "text": "Scheduling\n\n\nCommands\n can be run at certain times on recurring schedules.\n\n\nScheduled commands are different from queued commands.\nA command is queued when it is desirable to run the command once, as soon as possible.\nQueued commands are typically configured right before being dispatched.\nA command is scheduled when is it is desirable to run the command many times, on a definite schedule.\nScheduled commands are configured when their schedule is defined, in code. \n\n\nInEngine.NET takes a strictly programmatic approach to defining a schedule.\nA command schedule is defined in code, not in an external data store.\nThere are several advantages to this approach.\nOne advantage is that the schedule can be versioned alongside the command code.\nAnother advantage is that there is no overhead from managing additional state in an external data store.\n\n\nScheduling a Command\n\n\nA job schedule is created by adding a class to a plugin assembly that extends the \nInEngine.Core.AbstractPlugin\n class.\n\n\nThis is a simple example:\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMySchedulePlugin\n \n:\n \nAbstractPlugin\n\n    \n{\n\n        \npublic\n \noverride\n \nvoid\n \nSchedule\n(\nISchedule\n \nschedule\n)\n\n        \n{\n\n            \n// Schedule some jobs\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThe InEngine.NET scheduler automatically discovers this class in your plugin assembly.\nIt will call the \nAbstractPlugin.Schedule\n method with an initialized \nInEngine.Scheduling.Schedule\n object.\n\n\nThis is a command schedule class with a few scheduling examples:\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMySchedulePlugin\n \n:\n \nAbstractPlugin\n\n    \n{\n\n        \npublic\n \noverride\n \nvoid\n \nSchedule\n(\nISchedule\n \nschedule\n)\n\n        \n{\n\n            \n/* \n\n\n             * Run MyCommand every five minutes. \n\n\n             */\n\n            \nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nEveryFiveMinutes\n();\n\n\n            \n/* \n\n\n             * Run a lambda expression every ten minutes. \n\n\n             */\n\n            \nschedule\n.\nCommand\n(()\n \n=\n \nConsole\n.\nWriteLine\n(\nHello, world!\n)).\nEveryTenMinutes\n();\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nA command can be run on a custom cron schedule:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nCron\n(\n15 * * * * ?\n);\n\n\n\n\n\n\nThere are a number of additional methods for scheduling commands to run on common intervals.\n\n\nRun a command every second:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nEverySecond\n();\n\n\n\n\n\n\nRun a command every minute:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nEveryMinute\n();\n\n\n\n\n\n\nRun a command every 5 minutes:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nEveryFiveMinutes\n();\n\n\n\n\n\n\nRun a command every 10 minutes:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nEveryTenMinutes\n();\n\n\n\n\n\n\nRun a command every 15 minutes:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nEveryFifteenMinutes\n();\n\n\n\n\n\n\nRun a command every 30 minutes:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nEveryThirtyMinutes\n();\n\n\n\n\n\n\nRun a command hourly:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nHourly\n();\n\n\n\n\n\n\nRun a command hourly at a certain number of minutes past the hour (27 minutes in this example):\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nHourlyAt\n(\n27\n);\n\n\n\n\n\n\nRun a command daily:\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nDaily\n();\n\n\n\n\n\n\nRun a command daily at a specific time (at 10:30pm in this example):\n\n\nschedule\n.\nCommand\n(\nnew\n \nMyCommand\n()).\nDailyAt\n(\n22\n,\n \n30\n);\n\n\n\n\n\n\nIn a Chain\n\n\nA group of commands can be scheduled to run as an atomic batch.\n\n\nThis simple example schedules a group of imaginary file transfer commands to run in a chain:\n\n\nschedule\n.\nCommand\n(\nnew\n[]\n \n{\n\n    \nnew\n \nMyFileTransfer\n(\nfilePath1\n),\n\n    \nnew\n \nMyFileTransfer\n(\nfilePath2\n),\n\n    \nnew\n \nMyFileTransfer\n(\nfilePath3\n),\n\n\n})\n\n\n.\nDaily\n();\n\n\n\n\n\n\nThe chain of commands will stop executing if one of them fails.\nThe method \nFailed\n of the command that failed will be called.\nThis is a good place to add special logic that will allow the command to be recovered later, \nor to alert someone that manual intervention is necessary.  \n\n\nWith Life Cycle Methods\n\n\nCommands have optional life cycle methods that are initialized when a command is scheduled.\n\n\nThe \nBefore\n and \nAfter\n methods allow for some custom logic to be called before and after the command is run:\n\n\nschedule\n.\nCommand\n(\nnew\n \nCommand\n())\n\n    \n.\nEveryFiveMinutes\n()\n\n    \n.\nBefore\n(\nx\n \n=\n \nx\n.\nInfo\n(\nX refers to the command. Its methods can be used.\n))\n\n    \n.\nAfter\n(\nx\n \n=\n \nx\n.\nInfo\n(\nX refers to the command\n));\n\n\n\n\n\n\nIt is often useful to hit a URL before or after as well:\n\n\nschedule\n.\nCommand\n(\nnew\n \nCommand\n())\n\n    \n.\nEveryFiveMinutes\n()\n\n    \n.\nPingBefore\n(\nhttp://example.com\n)\n\n    \n.\nPingAfter\n(\nhttp://example.com\n);\n\n\n\n\n\n\nThe \nAbstractCommand\n class has an instance of \nInEngine.Core.IO.Write\n. \nThis class is more than just a wrapper for \nConsole.WriteLine\n.\n\n\nIt also allows these life cycle methods to send the command's text output to files or an email:  \n\n\nschedule\n.\nCommand\n(\nnew\n \nCommand\n)\n\n    \n.\nEveryFiveMinutes\n()\n\n    \n.\nWriteOutputTo\n(\n/some/path\n)\n\n    \n.\nAppendOutputTo\n(\n/some/path\n)\n\n    \n.\nEmailOutputTo\n(\nexample@inengine.net\n);\n\n\n\n\n\n\nThe \nBefore\n and \nAfter\n methods allow for some custom logic to be called before and after the command is run:\n\n\nschedule\n.\nCommand\n(\nnew\n \nCommand\n)\n\n    \n.\nEveryFiveMinutes\n()\n\n    \n.\nBefore\n(\nx\n \n=\n \nx\n.\nInfo\n(\nX refers to the command. Its methods can be used.\n))\n\n    \n.\nAfter\n(\nx\n \n=\n \nx\n.\nInfo\n(\nX refers to the command\n));\n\n\n\n\n\n\nCommand State\n\n\nCommands can have properties like any C# class.\nWhen running from the command line these properties are usually initialized with command line arguments.\nWhen run by the scheduler, the properties are specified when the command is scheduled.\nFor example, this command's \nFoo\n property will be auto-wired to \"bar\" when the command is later executed by the scheduler. \n\n\nschedule\n\n    \n.\nJob\n(\nnew\n \nMyCommand\n()\n \n{\n\n        \nFoo\n \n=\n \nbar\n\n    \n})\n\n    \n.\nEveryFiveMinutes\n();\n\n\n\n\n\n\nIf it is not desirable to auto-wire a property for some reason, simply decorate the property in the command class with the \nInEngine.Core.Scheduling.DoNotAutoWireAttribute\n class. \n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nAbstractCommand\n\n    \n{\n\n\n        [DoNotAutoWire]\n\n        \npublic\n \nstring\n \nFoo\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n        \npublic\n \noverride\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \n// Foo will be null here even if it is initialized before being scheduled. \n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRunning the Scheduler\n\n\nThere are a \nvariety of ways\n to run the scheduler. The simplest way is from the command line. \n\n\nRunning the scheduler from the CommandLine is useful for debugging or local development:\n\n\ninengine.exe -s\n\n\n\n\n\nIt can also be run on Mac and Linux with Mono via a shell wrapper script:\n\n\n./inengine -s", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling", 
            "text": "Commands  can be run at certain times on recurring schedules.  Scheduled commands are different from queued commands.\nA command is queued when it is desirable to run the command once, as soon as possible.\nQueued commands are typically configured right before being dispatched.\nA command is scheduled when is it is desirable to run the command many times, on a definite schedule.\nScheduled commands are configured when their schedule is defined, in code.   InEngine.NET takes a strictly programmatic approach to defining a schedule.\nA command schedule is defined in code, not in an external data store.\nThere are several advantages to this approach.\nOne advantage is that the schedule can be versioned alongside the command code.\nAnother advantage is that there is no overhead from managing additional state in an external data store.", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling-a-command", 
            "text": "A job schedule is created by adding a class to a plugin assembly that extends the  InEngine.Core.AbstractPlugin  class.  This is a simple example:  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MySchedulePlugin   :   AbstractPlugin \n     { \n         public   override   void   Schedule ( ISchedule   schedule ) \n         { \n             // Schedule some jobs \n         } \n     }  }   The InEngine.NET scheduler automatically discovers this class in your plugin assembly.\nIt will call the  AbstractPlugin.Schedule  method with an initialized  InEngine.Scheduling.Schedule  object.  This is a command schedule class with a few scheduling examples:  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MySchedulePlugin   :   AbstractPlugin \n     { \n         public   override   void   Schedule ( ISchedule   schedule ) \n         { \n             /*                * Run MyCommand every five minutes.                */ \n             schedule . Command ( new   MyCommand ()). EveryFiveMinutes (); \n\n             /*                * Run a lambda expression every ten minutes.                */ \n             schedule . Command (()   =   Console . WriteLine ( Hello, world! )). EveryTenMinutes (); \n         } \n     }  }   A command can be run on a custom cron schedule:  schedule . Command ( new   MyCommand ()). Cron ( 15 * * * * ? );   There are a number of additional methods for scheduling commands to run on common intervals.  Run a command every second:  schedule . Command ( new   MyCommand ()). EverySecond ();   Run a command every minute:  schedule . Command ( new   MyCommand ()). EveryMinute ();   Run a command every 5 minutes:  schedule . Command ( new   MyCommand ()). EveryFiveMinutes ();   Run a command every 10 minutes:  schedule . Command ( new   MyCommand ()). EveryTenMinutes ();   Run a command every 15 minutes:  schedule . Command ( new   MyCommand ()). EveryFifteenMinutes ();   Run a command every 30 minutes:  schedule . Command ( new   MyCommand ()). EveryThirtyMinutes ();   Run a command hourly:  schedule . Command ( new   MyCommand ()). Hourly ();   Run a command hourly at a certain number of minutes past the hour (27 minutes in this example):  schedule . Command ( new   MyCommand ()). HourlyAt ( 27 );   Run a command daily:  schedule . Command ( new   MyCommand ()). Daily ();   Run a command daily at a specific time (at 10:30pm in this example):  schedule . Command ( new   MyCommand ()). DailyAt ( 22 ,   30 );", 
            "title": "Scheduling a Command"
        }, 
        {
            "location": "/scheduling/#in-a-chain", 
            "text": "A group of commands can be scheduled to run as an atomic batch.  This simple example schedules a group of imaginary file transfer commands to run in a chain:  schedule . Command ( new []   { \n     new   MyFileTransfer ( filePath1 ), \n     new   MyFileTransfer ( filePath2 ), \n     new   MyFileTransfer ( filePath3 ),  })  . Daily ();   The chain of commands will stop executing if one of them fails.\nThe method  Failed  of the command that failed will be called.\nThis is a good place to add special logic that will allow the command to be recovered later, \nor to alert someone that manual intervention is necessary.", 
            "title": "In a Chain"
        }, 
        {
            "location": "/scheduling/#with-life-cycle-methods", 
            "text": "Commands have optional life cycle methods that are initialized when a command is scheduled.  The  Before  and  After  methods allow for some custom logic to be called before and after the command is run:  schedule . Command ( new   Command ()) \n     . EveryFiveMinutes () \n     . Before ( x   =   x . Info ( X refers to the command. Its methods can be used. )) \n     . After ( x   =   x . Info ( X refers to the command ));   It is often useful to hit a URL before or after as well:  schedule . Command ( new   Command ()) \n     . EveryFiveMinutes () \n     . PingBefore ( http://example.com ) \n     . PingAfter ( http://example.com );   The  AbstractCommand  class has an instance of  InEngine.Core.IO.Write . \nThis class is more than just a wrapper for  Console.WriteLine .  It also allows these life cycle methods to send the command's text output to files or an email:    schedule . Command ( new   Command ) \n     . EveryFiveMinutes () \n     . WriteOutputTo ( /some/path ) \n     . AppendOutputTo ( /some/path ) \n     . EmailOutputTo ( example@inengine.net );   The  Before  and  After  methods allow for some custom logic to be called before and after the command is run:  schedule . Command ( new   Command ) \n     . EveryFiveMinutes () \n     . Before ( x   =   x . Info ( X refers to the command. Its methods can be used. )) \n     . After ( x   =   x . Info ( X refers to the command ));", 
            "title": "With Life Cycle Methods"
        }, 
        {
            "location": "/scheduling/#command-state", 
            "text": "Commands can have properties like any C# class.\nWhen running from the command line these properties are usually initialized with command line arguments.\nWhen run by the scheduler, the properties are specified when the command is scheduled.\nFor example, this command's  Foo  property will be auto-wired to \"bar\" when the command is later executed by the scheduler.   schedule \n     . Job ( new   MyCommand ()   { \n         Foo   =   bar \n     }) \n     . EveryFiveMinutes ();   If it is not desirable to auto-wire a property for some reason, simply decorate the property in the command class with the  InEngine.Core.Scheduling.DoNotAutoWireAttribute  class.   using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   AbstractCommand \n     {          [DoNotAutoWire] \n         public   string   Foo   {   get ;   set ;   } \n\n         public   override   void   Run () \n         { \n             // Foo will be null here even if it is initialized before being scheduled.  \n         } \n     }  }", 
            "title": "Command State"
        }, 
        {
            "location": "/scheduling/#running-the-scheduler", 
            "text": "There are a  variety of ways  to run the scheduler. The simplest way is from the command line.   Running the scheduler from the CommandLine is useful for debugging or local development:  inengine.exe -s  It can also be run on Mac and Linux with Mono via a shell wrapper script:  ./inengine -s", 
            "title": "Running the Scheduler"
        }, 
        {
            "location": "/queuing/", 
            "text": "Queuing\n\n\nInEngine.NET's queue functionality allows for commands to be run in the background via a \npublish/subscribe\n model.\nA command should be queued when it is desirable to run the command once, as soon as possible, in a background task.\n\n\nQueuing is especially important for Web sites and applications. \nQueuing is like the sister technology of caching.\nCaching makes page loads faster when reading data from a database, or serving static assets, by drastically reducing direct database and file system read operations. \nQueuing makes page loads faster when writing data to a database, or performing other blocking tasks, by pushing them into the background.\nSome common examples are sending emails, importing CSV files into a database, transforming an image file, and processing a shopping cart order.\nIt is not appropriate to use queuing if output from the task is needed immediately in the response of a Web request.\n\n\nQueue Drivers\n\n\nTo make use of queue features, a queue driver must be specified in \nappsettings.json\n.\n\n\nThese are the available drivers...\n\n\nFile\n\n\nThe file driver writes queued messages to the file system. \nIt is useful for testing and development, but probably not suitable for production.\n\n\nRedis\n\n\nRedis is suitable for production use. \nInEngine.NET utilizes Redis' durable queue features which mean messages will not be lost if InEngine.NET unexpectedly fails. \n\n\nRedis can be installed on Ubuntu with this command:\n\n\nsudo apt-get install redis-server\n\n\n\n\n\nStart Redis with this command:\n\n\nsudo service redis start\n\n\n\n\n\n\nIt is highly recommended to \nset a password\n for Redis.\n\n\n\n\nSync\n\n\nThe sync driver causes the publish command to run a published command synchronously.\nAll other queue commands and methods are not supported and will throw an exception if called.\nThis driver can be useful for plugin development and testing.\n\n\nEnqueuing Commands\n\n\nWith C# Classes\n\n\nCommands\n can be enqueued programmatically with the \nInEngine.Core.Queuing.Enqueue\n class:\n\n\nEnqueue\n.\nCommand\n(\nnew\n \nMyCommand\n())\n\n       \n.\nDispatch\n();\n\n\n\n\n\n\nOr enqueue to the secondary queue:\n\n\nEnqueue\n.\nCommand\n(\nnew\n \nMyCommand\n())\n\n       \n.\nToSecondaryQueue\n()\n\n       \n.\nDispatch\n();\n\n\n\n\n\n\nEnqueue is just a wrapper.\nIt is possible to peel back the covers to get to the queue client.\n\n\n// Enqueue.Command actually returns a life cycle object...\n\n\nvar\n \ncommandToDispatch\n \n=\n \nEnqueue\n.\nCommand\n(\nnew\n \nMyCommand\n());\n\n\n\n// The life cycle object has a QueueAdapter that can be set...\n\n\nvar\n \nshouldUseSecondaryQueue\n \n=\n \ntrue\n;\n\n\ncommandToDispatch\n.\nQueueAdapter\n \n=\n \nQueueAdapter\n.\nMake\n(\nshouldUseSecondaryQueue\n);\n\n\n\n// Now dispatch the command... \n\n\ncommandToDispatch\n.\nDispatch\n();\n\n\n\n\n\n\nWith Lambda Expressions\n\n\nLambda expressions, aka anonymous functions, can be queued.\nThe disadvantage to queuing lambdas is that the helpful functionality available in \nInEngine.Core.AbstractCommand\n is not available.  \n\n\nThis is how you queue a lambda:\n\n\nEnqueue\n.\nCommand\n(()\n \n=\n \nConsole\n.\nWriteLine\n(\nHello, world!\n))\n\n       \n.\nDispatch\n();\n\n\n\n\n\n\nWith the \"exec\" Command\n\n\nThe \nexec\n command allows for external programs to be executed.\n\n\ninengine queue:publish --plugin\n=\nInEngine.Core --command\n=\nexe --args\n=\ncommand=/usr/bin/python\n \nargs=--version\n\n\n\n\n\n\n\n\nDo not include \"--\" for the command and args parameters.\n\n\nThis is purely to make parsing easier internally.\n\n\n\n\nSequentially In a Chain\n\n\nChained commands run in the order specified.\nThis is useful for when order matters.\n\n\nAlso, if one command in the chain fails, then subsequent commands are not run at all.\nThis affords the opportunity to add additional code that records which command failed to notify someone that manual intervention is necessary, \nor some other error handling functionality.\n\n\nHere is a an example of how to chain a series of (imaginary) file transfer commands together:\n\n\nEnqueue\n.\nCommand\n(\nnew\n[]\n \n{\n\n            \nnew\n \nMyFileTransfer\n(\nfilePath1\n),\n\n            \nnew\n \nMyFileTransfer\n(\nfilePath2\n),\n\n            \nnew\n \nMyFileTransfer\n(\nfilePath3\n),\n\n       \n})\n\n       \n.\nDispatch\n();\n\n\n\n\n\n\nIt is also possible to enqueue a list of different commands:\n\n\nEnqueue\n.\nCommand\n(\nnew\n \nList\nAbstractCommand\n()\n \n{\n\n           \nnew\n \nAlwaysSucceed\n(),\n\n           \nnew\n \nEcho\n()\n \n{\n \nVerbatimText\n \n=\n \nHello, world!\n},\n\n       \n})\n\n        \n.\nDispatch\n();\n\n\n\n\n\n\nWith Life Cycle Methods\n\n\nCommands have optional life cycle methods that are initialized when a command is enqueued.\nThis is similar to scheduling life cycle methods, but a queue does not have the \nBefore\n and \nAfter\n method.\nIt has the rest.\n\n\nIt is often useful to hit a URL before or after the command runs:\n\n\nEnqueue\n.\nCommand\n(\nnew\n \nCommand\n())\n\n    \n.\nEveryFiveMinutes\n()\n\n    \n.\nPingBefore\n(\nhttp://example.com\n)\n\n    \n.\nPingAfter\n(\nhttp://example.com\n);\n\n\n\n\n\n\nThe \nAbstractCommand\n class has an instance of \nInEngine.Core.IO.Write\n. \nThis class is more than just a wrapper for \nConsole.WriteLine\n.\n\n\nIt also allows these life cycle methods to send the command's text output to files or an email:  \n\n\nEnqueue\n.\nCommand\n(\nnew\n \nCommand\n)\n\n    \n.\nEveryFiveMinutes\n()\n\n    \n.\nWriteOutputTo\n(\n/some/path\n)\n\n    \n.\nAppendOutputTo\n(\n/some/path\n)\n\n    \n.\nEmailOutputTo\n(\nexample@inengine.net\n);\n\n\n\n\n\n\nFrom the Command Line\n\n\nCommands can be published from the command line as well.\nNote that all queue commands reside in the \nInEngine.Core\n plugin.\nThis is an example of how to publish a command from the CLI by specifying the command's plugin, class name, and arguments:\n\n\ninengine.exe queue:publish --plugin\n=\nMyCommandPlugin --class\n=\nMyCommand --args \ntext=bar\n\n\n\n\n\n\nThere is an \"Echo\" command in the \nInEngine.Core\n package. It is useful for end-to-end testing with the queue feature.\n\n\ninengine.exe queue:publish --plugin\n=\nInEngine.Core --class\n=\nInEngine.Core.Commands.Echo --args \ntext=foo\n\n\n\n\n\n\nThe command verb can also be specified instead of the full class name:\n\n\ninengine.exe queue:publish --plugin\n=\nInEngine.Core --command\n=\necho--args \ntext=foo\n\n\n\n\n\n\nConsuming Commands\n\n\nFrom the Command Line\n\n\nCommands can be consumed from the command line with this simple command:\n\n\ninengine.exe queue:consume\n\n\n\n\n\nUse the \n--secondary\n argument to consume the secondary queue instead of the primary queue:\n\n\ninengine.exe queue:consume --secondary\n\n\n\n\n\nWith the Scheduler\n\n\nThe InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of \nways to run the scheduler\n.\n\n\nFrom Code\n\n\nIt should (probably) never be necessary to manually consume commands in code, but it is possible. \n\n\nConsuming a command is accomplished with the \nInEngine.Core.Queuing.Commands.Consume\n class:\n\n\nnew\n \nConsume\n().\nRun\n();\n\n\n\n\n\n\nOr consume the secondary queue:\n\n\nnew\n \nConsume\n \n{\n\n    \nUseSecondaryQueue\n \n=\n \ntrue\n\n\n}.\nRun\n();\n\n\n\n\n\n\nExamining the Queue\n\n\nViewing Queue Lengths\n\n\nThe \nqueue:length\n command shows a quick summary of pending, in-progress, and failed commands in the primary and secondary queues:\n\n\ninengine.exe queue:length\n\n\n\n\n\nPeek at Queued Commands\n\n\nThe \nqueue:peek\n command allows for queued commands to be inspected:\n\n\ninengine.exe queue:peek --pending --in-progress --failed\n\n\n\n\n\nIt is of course possible to peek in the secondary queues:\n\n\ninengine.exe queue:peek --pending --secondary\n\n\n\n\n\nQueued commands can be viewed in JSON which maybe useful for debugging:\n\n\ninengine.exe queue:peek --pending --json\n\n\n\n\n\nBy default, up to the first 10 messages will be retrieved, but the range is configurable:\n\n\ninengine.exe queue:peek --pending --to\n=\n100\n\n\n\n\n\n\nA slice of the queue can be retrieved using the from argument.\nFor example, this queue:peek call retrieves the 100-200 queued commands:\n\n\ninengine.exe queue:peek --pending --from\n=\n100\n --to\n=\n200\n\n\n\n\n\n\nRe-queuing Failed Commands\n\n\nCommands that throw an exception are put in a special \"failed\" queue. \nThey can be republished with the \nqueue:republish\n command:\n\n\ninengine.exe queue:republish\n\n\n\n\n\nFailed secondary queue commands can be republished as well:\n\n\ninengine.exe queue:republish --secondary\n\n\n\n\n\nBy default, only 100 failed commands are republished at a time.\nThe is configurable:\n\n\ninengine.exe queue:republish --limit\n=\n1000\n\n\n\n\n\n\nPrimary and Secondary Queue\n\n\nOther than the fact that the primary queue is used by default, there is no difference between the primary and secondary queues. \nHowever, it is often desirable to use two queues. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.\n\n\nWhat about 3, 4, or 900 queues? Managing numerous queues gets to be a pain and, practically speaking, is probably unnecessary.\nIf it is desirable, different \nconfiguration files\n can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it with the -c argument:\n\n\ninengine.exe -cMyCustomSettingsFile.json queue:consume\n\n\n\n\n\nMessage Compression\n\n\nMessages can be compressed when saved in the queue. \nIt is important to understand the trade-offs of this feature before enabling it.\nIf the queued commands are too small to benefit from being compressed, then compressing them wastes resources.\nCompressing messages takes more CPU resources and might negatively impact queue throughput if the queued commands do not have a lot of internal state.\n\n\nIf the commands have a lot of internal state, then this feature will reduce the queue's memory consumption.\nAlso, in a high-throughput scenario, where network bandwidth is limited, this feature can greatly reduce the amount of bandwidth used.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#queuing", 
            "text": "InEngine.NET's queue functionality allows for commands to be run in the background via a  publish/subscribe  model.\nA command should be queued when it is desirable to run the command once, as soon as possible, in a background task.  Queuing is especially important for Web sites and applications. \nQueuing is like the sister technology of caching.\nCaching makes page loads faster when reading data from a database, or serving static assets, by drastically reducing direct database and file system read operations. \nQueuing makes page loads faster when writing data to a database, or performing other blocking tasks, by pushing them into the background.\nSome common examples are sending emails, importing CSV files into a database, transforming an image file, and processing a shopping cart order.\nIt is not appropriate to use queuing if output from the task is needed immediately in the response of a Web request.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#queue-drivers", 
            "text": "To make use of queue features, a queue driver must be specified in  appsettings.json .  These are the available drivers...", 
            "title": "Queue Drivers"
        }, 
        {
            "location": "/queuing/#file", 
            "text": "The file driver writes queued messages to the file system. \nIt is useful for testing and development, but probably not suitable for production.", 
            "title": "File"
        }, 
        {
            "location": "/queuing/#redis", 
            "text": "Redis is suitable for production use. \nInEngine.NET utilizes Redis' durable queue features which mean messages will not be lost if InEngine.NET unexpectedly fails.   Redis can be installed on Ubuntu with this command:  sudo apt-get install redis-server  Start Redis with this command:  sudo service redis start  \nIt is highly recommended to  set a password  for Redis.", 
            "title": "Redis"
        }, 
        {
            "location": "/queuing/#sync", 
            "text": "The sync driver causes the publish command to run a published command synchronously.\nAll other queue commands and methods are not supported and will throw an exception if called.\nThis driver can be useful for plugin development and testing.", 
            "title": "Sync"
        }, 
        {
            "location": "/queuing/#enqueuing-commands", 
            "text": "", 
            "title": "Enqueuing Commands"
        }, 
        {
            "location": "/queuing/#with-c-classes", 
            "text": "Commands  can be enqueued programmatically with the  InEngine.Core.Queuing.Enqueue  class:  Enqueue . Command ( new   MyCommand ()) \n        . Dispatch ();   Or enqueue to the secondary queue:  Enqueue . Command ( new   MyCommand ()) \n        . ToSecondaryQueue () \n        . Dispatch ();   Enqueue is just a wrapper.\nIt is possible to peel back the covers to get to the queue client.  // Enqueue.Command actually returns a life cycle object...  var   commandToDispatch   =   Enqueue . Command ( new   MyCommand ());  // The life cycle object has a QueueAdapter that can be set...  var   shouldUseSecondaryQueue   =   true ;  commandToDispatch . QueueAdapter   =   QueueAdapter . Make ( shouldUseSecondaryQueue );  // Now dispatch the command...   commandToDispatch . Dispatch ();", 
            "title": "With C# Classes"
        }, 
        {
            "location": "/queuing/#with-lambda-expressions", 
            "text": "Lambda expressions, aka anonymous functions, can be queued.\nThe disadvantage to queuing lambdas is that the helpful functionality available in  InEngine.Core.AbstractCommand  is not available.    This is how you queue a lambda:  Enqueue . Command (()   =   Console . WriteLine ( Hello, world! )) \n        . Dispatch ();", 
            "title": "With Lambda Expressions"
        }, 
        {
            "location": "/queuing/#with-the-exec-command", 
            "text": "The  exec  command allows for external programs to be executed.  inengine queue:publish --plugin = InEngine.Core --command = exe --args = command=/usr/bin/python   args=--version    Do not include \"--\" for the command and args parameters.  This is purely to make parsing easier internally.", 
            "title": "With the \"exec\" Command"
        }, 
        {
            "location": "/queuing/#sequentially-in-a-chain", 
            "text": "Chained commands run in the order specified.\nThis is useful for when order matters.  Also, if one command in the chain fails, then subsequent commands are not run at all.\nThis affords the opportunity to add additional code that records which command failed to notify someone that manual intervention is necessary, \nor some other error handling functionality.  Here is a an example of how to chain a series of (imaginary) file transfer commands together:  Enqueue . Command ( new []   { \n             new   MyFileTransfer ( filePath1 ), \n             new   MyFileTransfer ( filePath2 ), \n             new   MyFileTransfer ( filePath3 ), \n        }) \n        . Dispatch ();   It is also possible to enqueue a list of different commands:  Enqueue . Command ( new   List AbstractCommand ()   { \n            new   AlwaysSucceed (), \n            new   Echo ()   {   VerbatimText   =   Hello, world! }, \n        }) \n         . Dispatch ();", 
            "title": "Sequentially In a Chain"
        }, 
        {
            "location": "/queuing/#with-life-cycle-methods", 
            "text": "Commands have optional life cycle methods that are initialized when a command is enqueued.\nThis is similar to scheduling life cycle methods, but a queue does not have the  Before  and  After  method.\nIt has the rest.  It is often useful to hit a URL before or after the command runs:  Enqueue . Command ( new   Command ()) \n     . EveryFiveMinutes () \n     . PingBefore ( http://example.com ) \n     . PingAfter ( http://example.com );   The  AbstractCommand  class has an instance of  InEngine.Core.IO.Write . \nThis class is more than just a wrapper for  Console.WriteLine .  It also allows these life cycle methods to send the command's text output to files or an email:    Enqueue . Command ( new   Command ) \n     . EveryFiveMinutes () \n     . WriteOutputTo ( /some/path ) \n     . AppendOutputTo ( /some/path ) \n     . EmailOutputTo ( example@inengine.net );", 
            "title": "With Life Cycle Methods"
        }, 
        {
            "location": "/queuing/#from-the-command-line", 
            "text": "Commands can be published from the command line as well.\nNote that all queue commands reside in the  InEngine.Core  plugin.\nThis is an example of how to publish a command from the CLI by specifying the command's plugin, class name, and arguments:  inengine.exe queue:publish --plugin = MyCommandPlugin --class = MyCommand --args  text=bar   There is an \"Echo\" command in the  InEngine.Core  package. It is useful for end-to-end testing with the queue feature.  inengine.exe queue:publish --plugin = InEngine.Core --class = InEngine.Core.Commands.Echo --args  text=foo   The command verb can also be specified instead of the full class name:  inengine.exe queue:publish --plugin = InEngine.Core --command = echo--args  text=foo", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#consuming-commands", 
            "text": "", 
            "title": "Consuming Commands"
        }, 
        {
            "location": "/queuing/#from-the-command-line_1", 
            "text": "Commands can be consumed from the command line with this simple command:  inengine.exe queue:consume  Use the  --secondary  argument to consume the secondary queue instead of the primary queue:  inengine.exe queue:consume --secondary", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#with-the-scheduler", 
            "text": "The InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of  ways to run the scheduler .", 
            "title": "With the Scheduler"
        }, 
        {
            "location": "/queuing/#from-code", 
            "text": "It should (probably) never be necessary to manually consume commands in code, but it is possible.   Consuming a command is accomplished with the  InEngine.Core.Queuing.Commands.Consume  class:  new   Consume (). Run ();   Or consume the secondary queue:  new   Consume   { \n     UseSecondaryQueue   =   true  }. Run ();", 
            "title": "From Code"
        }, 
        {
            "location": "/queuing/#examining-the-queue", 
            "text": "", 
            "title": "Examining the Queue"
        }, 
        {
            "location": "/queuing/#viewing-queue-lengths", 
            "text": "The  queue:length  command shows a quick summary of pending, in-progress, and failed commands in the primary and secondary queues:  inengine.exe queue:length", 
            "title": "Viewing Queue Lengths"
        }, 
        {
            "location": "/queuing/#peek-at-queued-commands", 
            "text": "The  queue:peek  command allows for queued commands to be inspected:  inengine.exe queue:peek --pending --in-progress --failed  It is of course possible to peek in the secondary queues:  inengine.exe queue:peek --pending --secondary  Queued commands can be viewed in JSON which maybe useful for debugging:  inengine.exe queue:peek --pending --json  By default, up to the first 10 messages will be retrieved, but the range is configurable:  inengine.exe queue:peek --pending --to = 100   A slice of the queue can be retrieved using the from argument.\nFor example, this queue:peek call retrieves the 100-200 queued commands:  inengine.exe queue:peek --pending --from = 100  --to = 200", 
            "title": "Peek at Queued Commands"
        }, 
        {
            "location": "/queuing/#re-queuing-failed-commands", 
            "text": "Commands that throw an exception are put in a special \"failed\" queue. \nThey can be republished with the  queue:republish  command:  inengine.exe queue:republish  Failed secondary queue commands can be republished as well:  inengine.exe queue:republish --secondary  By default, only 100 failed commands are republished at a time.\nThe is configurable:  inengine.exe queue:republish --limit = 1000", 
            "title": "Re-queuing Failed Commands"
        }, 
        {
            "location": "/queuing/#primary-and-secondary-queue", 
            "text": "Other than the fact that the primary queue is used by default, there is no difference between the primary and secondary queues. \nHowever, it is often desirable to use two queues. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.  What about 3, 4, or 900 queues? Managing numerous queues gets to be a pain and, practically speaking, is probably unnecessary.\nIf it is desirable, different  configuration files  can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it with the -c argument:  inengine.exe -cMyCustomSettingsFile.json queue:consume", 
            "title": "Primary and Secondary Queue"
        }, 
        {
            "location": "/queuing/#message-compression", 
            "text": "Messages can be compressed when saved in the queue. \nIt is important to understand the trade-offs of this feature before enabling it.\nIf the queued commands are too small to benefit from being compressed, then compressing them wastes resources.\nCompressing messages takes more CPU resources and might negatively impact queue throughput if the queued commands do not have a lot of internal state.  If the commands have a lot of internal state, then this feature will reduce the queue's memory consumption.\nAlso, in a high-throughput scenario, where network bandwidth is limited, this feature can greatly reduce the amount of bandwidth used.", 
            "title": "Message Compression"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nInEngine Settings\n\n\nConfiguration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution.\nThe \n-c, --configuration\n argument can also be used to specify an alternate configuration file.\n\n\n{\n\n  \nInEngine\n:\n \n{\n\n    \nPlugins\n:\n \n{\n\n      \nMyPlugin\n:\n \n/path/to/plugin/assembly\n\n    \n},\n\n    \nExecWhitelist\n:\n \n{\n\n      \nfoo\n:\n \n/path/to/foo.exe\n\n    \n},\n\n    \nMail\n:\n \n{\n\n      \nHost\n:\n \nlocalhost\n,\n\n      \nPort\n:\n \n25\n,\n\n      \nFrom\n:\n \nno-reply@inengine.net\n\n    \n},\n\n    \nQueue\n:\n \n{\n\n      \nUseCompression\n:\n \nfalse\n,\n\n      \nPrimaryQueueConsumers\n:\n  \n16\n,\n\n      \nSecondaryQueueConsumers\n:\n \n4\n,\n\n      \nQueueDriver\n:\n \nredis\n,\n\n      \nQueueName\n:\n \nInEngineQueue\n,\n\n      \nRedisHost\n:\n \nlocalhost\n,\n\n      \nRedisPort\n:\n \n6379\n,\n\n      \nRedisDb\n:\n \n0\n,\n\n      \nRedisPassword\n:\n \n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\nTop-level Settings\n\n\n\n\n\n\n\n\nSetting\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPlugins\n\n\nobject\n\n\nA set of key/value pairs, where the value is the directory where the plugin is located and the key is the plugin name sans .dll extension.\n\n\n\n\n\n\nExecWhitelist\n\n\nobject\n\n\nA set of key/value pairs, where the value is the file system path of an executable and the key is a command alias.\n\n\n\n\n\n\n\n\nMail Settings\n\n\n\n\n\n\n\n\nSetting\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nHost\n\n\nstring\n\n\nThe hostname of an SMTP server.\n\n\n\n\n\n\nPort\n\n\ninteger\n\n\nThe port of an SMTP server.\n\n\n\n\n\n\nFrom\n\n\nstring\n\n\nThe default email address used to send email from.\n\n\n\n\n\n\n\n\nQueue Settings\n\n\n\n\n\n\n\n\nSetting\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nUseCompression\n\n\nbool\n\n\nA situation performance optimization that compresses queued messages.\n\n\n\n\n\n\nPrimaryQueueConsumers\n\n\nstring\n\n\nThe number of consumers to schedule for the secondary queue.\n\n\n\n\n\n\nSecondaryQueueConsumers\n\n\nstring\n\n\nThe number of consumers to schedule for the secondary queue.\n\n\n\n\n\n\nQueueDriver\n\n\nstring\n\n\nThe driver to use to interact with a queue data store.\n\n\n\n\n\n\nQueueName\n\n\nstring\n\n\nThe base name of the queue, used to form the Redis Queue keys.\n\n\n\n\n\n\nRedisHost\n\n\nstring\n\n\nThe Redis hostname to connect to.\n\n\n\n\n\n\nRedisPort\n\n\ninteger\n\n\nRedis's port.\n\n\n\n\n\n\nRedisDb\n\n\ninteger\n\n\nThe Redis database - 0-15\n\n\n\n\n\n\nRedisPassword\n\n\nstring\n\n\nThe Redis auth password\n\n\n\n\n\n\n\n\nLogging Settings\n\n\nAny exceptions thrown by a command will be logged, provided NLog is configured to log exceptions. \nThe \nNLog configuration\n file needs to be setup with something like this: \n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nnlog\n \nxmlns=\nhttp://www.nlog-project.org/schemas/NLog.xsd\n\n      \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n\n    \ntargets\n\n        \ntarget\n \nname=\nlogfile\n \nxsi:type=\nFile\n \nfileName=\ninengine.log\n \n/\n\n    \n/targets\n\n\n    \nrules\n\n        \nlogger\n \nname=\n*\n \nminlevel=\nError\n \nwriteTo=\nlogfile\n \n/\n\n    \n/rules\n\n\n/nlog\n\n\n\n\n\n\nInEngine.Core does not depend explicitly on NLog, but rather \nCommon.Logging\n.\nThis means that any logging framework that Common.Logging supports can be used.\nConfiguring Common.Logging to use a different logging framework is out of the scope of this documentation.", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#inengine-settings", 
            "text": "Configuration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution.\nThe  -c, --configuration  argument can also be used to specify an alternate configuration file.  { \n   InEngine :   { \n     Plugins :   { \n       MyPlugin :   /path/to/plugin/assembly \n     }, \n     ExecWhitelist :   { \n       foo :   /path/to/foo.exe \n     }, \n     Mail :   { \n       Host :   localhost , \n       Port :   25 , \n       From :   no-reply@inengine.net \n     }, \n     Queue :   { \n       UseCompression :   false , \n       PrimaryQueueConsumers :    16 , \n       SecondaryQueueConsumers :   4 , \n       QueueDriver :   redis , \n       QueueName :   InEngineQueue , \n       RedisHost :   localhost , \n       RedisPort :   6379 , \n       RedisDb :   0 , \n       RedisPassword :   \n     } \n   }  }", 
            "title": "InEngine Settings"
        }, 
        {
            "location": "/configuration/#top-level-settings", 
            "text": "Setting  Type  Description      Plugins  object  A set of key/value pairs, where the value is the directory where the plugin is located and the key is the plugin name sans .dll extension.    ExecWhitelist  object  A set of key/value pairs, where the value is the file system path of an executable and the key is a command alias.", 
            "title": "Top-level Settings"
        }, 
        {
            "location": "/configuration/#mail-settings", 
            "text": "Setting  Type  Description      Host  string  The hostname of an SMTP server.    Port  integer  The port of an SMTP server.    From  string  The default email address used to send email from.", 
            "title": "Mail Settings"
        }, 
        {
            "location": "/configuration/#queue-settings", 
            "text": "Setting  Type  Description      UseCompression  bool  A situation performance optimization that compresses queued messages.    PrimaryQueueConsumers  string  The number of consumers to schedule for the secondary queue.    SecondaryQueueConsumers  string  The number of consumers to schedule for the secondary queue.    QueueDriver  string  The driver to use to interact with a queue data store.    QueueName  string  The base name of the queue, used to form the Redis Queue keys.    RedisHost  string  The Redis hostname to connect to.    RedisPort  integer  Redis's port.    RedisDb  integer  The Redis database - 0-15    RedisPassword  string  The Redis auth password", 
            "title": "Queue Settings"
        }, 
        {
            "location": "/configuration/#logging-settings", 
            "text": "Any exceptions thrown by a command will be logged, provided NLog is configured to log exceptions. \nThe  NLog configuration  file needs to be setup with something like this:   ?xml version= 1.0  encoding= utf-8  ?  nlog   xmlns= http://www.nlog-project.org/schemas/NLog.xsd \n       xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n\n     targets \n         target   name= logfile   xsi:type= File   fileName= inengine.log   / \n     /targets \n\n     rules \n         logger   name= *   minlevel= Error   writeTo= logfile   / \n     /rules  /nlog   InEngine.Core does not depend explicitly on NLog, but rather  Common.Logging .\nThis means that any logging framework that Common.Logging supports can be used.\nConfiguring Common.Logging to use a different logging framework is out of the scope of this documentation.", 
            "title": "Logging Settings"
        }, 
        {
            "location": "/server/", 
            "text": "Server\n\n\nWhen run as a service, InEngine runs scheduled commands in the background and actively listens for commands to be queued.\n\n\nRunning the Server\n\n\nIn the Foreground\n\n\nRunning the server from the CommandLine is useful for debugging or local development:\n\n\ninengine.exe -s\n\n\n\n\n\nIt can also be run on Mac and Linux with Mono via a shell wrapper script:\n\n\n./inengine -s\n\n\n\n\n\nOn Windows as a Service\n\n\nRun the \nInstall.ps1\n PowerShell script in the InEngine directory to install the InEngine as a service. \nThe script needs to be run as an administrator. \nThe script will register the service at the location where the script is run - i.e. put the files where you want them installed before running the installation script.\n\n\nps Install.ps1\n\n\n\n\n\nSimply run the \nUninstall.ps1\n script with elevated permissions to remove the service.\n\n\nps Uninstall.ps1\n\n\n\n\n\nOn Linux with Supervisor\n\n\nSupervisor is a process control system for Linux. \nIt has extensive \ndocumentation\n, but the following should be enough to get started.\n\n\nInstalling Supervisor\n\n\nThis command installs Supervisor on Ubuntu:\n\n\nsudo apt-get install supervisor\n\n\n\n\n\nConfiguring Supervisor\n\n\nSupervisor configuration files are stored in the \n/etc/supervisor/conf.d\n directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called \n/etc/supervisor/conf.d/inengine-scheduler.conf\n. \n\n\n[program:inengine]\n\n\nprocess_name\n=\n%(program_name)s_%(process_num)02d\n\n\ndirectory\n=\n/path/to/inengine\n\n\ncommand\n=\nmono inengine.exe -s\n\n\nautostart\n=\ntrue\n\n\nautorestart\n=\ntrue\n\n\nuser\n=\nInEngine\n\n\nnumprocs\n=\n1\n\n\nredirect_stderr\n=\ntrue\n\n\nstdout_logfile\n=\n./scheduler.log\n\n\n\n\n\n\nStarting Supervisor\n\n\nWhenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.\n\n\nsudo supervisorctl reread\nsudo supervisorctl update\n\n\n\n\n\nNow, simply start the server workers with the \nsupervisorctl\n program:\n\n\nsudo supervisorctl start inengine:*\n\n\n\n\n\nIn a Container with Docker\n\n\nInstall \nDocker\n first, then pull the \nethanhann/inengine\n image:\n\n\ndocker pull ethanhann/inengine:latest\n\n\n\n\n\nNow run the InEngine in server mode:\n\n\n```bash\ndocker run --rm inengine -s", 
            "title": "Server"
        }, 
        {
            "location": "/server/#server", 
            "text": "When run as a service, InEngine runs scheduled commands in the background and actively listens for commands to be queued.", 
            "title": "Server"
        }, 
        {
            "location": "/server/#running-the-server", 
            "text": "", 
            "title": "Running the Server"
        }, 
        {
            "location": "/server/#in-the-foreground", 
            "text": "Running the server from the CommandLine is useful for debugging or local development:  inengine.exe -s  It can also be run on Mac and Linux with Mono via a shell wrapper script:  ./inengine -s", 
            "title": "In the Foreground"
        }, 
        {
            "location": "/server/#on-windows-as-a-service", 
            "text": "Run the  Install.ps1  PowerShell script in the InEngine directory to install the InEngine as a service. \nThe script needs to be run as an administrator. \nThe script will register the service at the location where the script is run - i.e. put the files where you want them installed before running the installation script.  ps Install.ps1  Simply run the  Uninstall.ps1  script with elevated permissions to remove the service.  ps Uninstall.ps1", 
            "title": "On Windows as a Service"
        }, 
        {
            "location": "/server/#on-linux-with-supervisor", 
            "text": "Supervisor is a process control system for Linux. \nIt has extensive  documentation , but the following should be enough to get started.", 
            "title": "On Linux with Supervisor"
        }, 
        {
            "location": "/server/#installing-supervisor", 
            "text": "This command installs Supervisor on Ubuntu:  sudo apt-get install supervisor", 
            "title": "Installing Supervisor"
        }, 
        {
            "location": "/server/#configuring-supervisor", 
            "text": "Supervisor configuration files are stored in the  /etc/supervisor/conf.d  directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called  /etc/supervisor/conf.d/inengine-scheduler.conf .   [program:inengine]  process_name = %(program_name)s_%(process_num)02d  directory = /path/to/inengine  command = mono inengine.exe -s  autostart = true  autorestart = true  user = InEngine  numprocs = 1  redirect_stderr = true  stdout_logfile = ./scheduler.log", 
            "title": "Configuring Supervisor"
        }, 
        {
            "location": "/server/#starting-supervisor", 
            "text": "Whenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.  sudo supervisorctl reread\nsudo supervisorctl update  Now, simply start the server workers with the  supervisorctl  program:  sudo supervisorctl start inengine:*", 
            "title": "Starting Supervisor"
        }, 
        {
            "location": "/server/#in-a-container-with-docker", 
            "text": "Install  Docker  first, then pull the  ethanhann/inengine  image:  docker pull ethanhann/inengine:latest  Now run the InEngine in server mode:  ```bash\ndocker run --rm inengine -s", 
            "title": "In a Container with Docker"
        }
    ]
}