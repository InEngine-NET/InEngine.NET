{
    "docs": [
        {
            "location": "/", 
            "text": "InEngine.NET allows commands to be queued, scheduled, and run directly. \n\n\nGet started by reading up on \ncommands\n, then \nscheduling\n and \nqueuing\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/commands/", 
            "text": "Commands\n\n\nCommands are the fundamental abstraction used to run custom logic.\n\n\nCreate a Command\n\n\nThe InEngine.Core package is required. Install it into your own Visual Studio project.\n\n\nPackage Manager\n\n\nInstall-Package InEngine.Core\n\n\n\n\n\nNuget CLI\n\n\nnuget install InEgine.Core\n\n\n\n\n\n.NET CLI\n\n\ndotnet add package InEngine.Core\n\n\n\n\n\nPaket CLI\n\n\npaket add InEngine.Core\n\n\n\n\n\nAdding a class that implements \nInEngine.Core.ICommand\n is the simplest way to create a command.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nICommand\n\n    \n{\n\n        \npublic\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \nConsole\n.\nWriteLine\n(\nHello, world!\n);\n\n            \nreturn\n \nnew\n \nvoid\n(\ntrue\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nExtending the \nInEngine.Core.AbstractCommand\n class adds extra functionality, like a logger, a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyCommand\n \n:\n \nAbstractCommand\n\n    \n{\n\n        \npublic\n \noverride\n \nvoid\n \nRun\n()\n\n        \n{\n\n            \nConsole\n.\nWriteLine\n(\nHello, world!\n);\n\n            \nreturn\n \nnew\n \nvoid\n(\ntrue\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRun a Command\n\n\nCreate a class that implements \nInEngine.Core.IOptions\n in the same assembly as the command class.\nAdd a VerbOptions attribute from the CommandLine namespace that defines the name of the command and optional help text.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method.  \n\n\nusing\n \nCommandLine\n;\n\n\nusing\n \nCommandLine.Text\n;\n\n\nusing\n \nInEngine.Core\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nMyOptions\n \n:\n \nIOptions\n\n    \n{\n\n\n        [VerbOption(\nmy-command\n, HelpText=\nMy example command.\n)]\n\n        \npublic\n \nMyCommand\n \nMyCommand\n \n{\n \nget\n;\n \nset\n;\n \n}\n\n\n\n        [HelpVerbOption]\n\n        \npublic\n \nstring\n \nGetUsage\n(\nstring\n \nverb\n)\n\n        \n{\n\n            \nreturn\n \nHelpText\n.\nAutoBuild\n(\nthis\n,\n \nverb\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nDownload the InEngine binary distribution, from the \nGitHub Releases\n page, that matches the version of the InEngine.Core package you included.\n\n\nCopy your project's DLLs into the same directory as inengine.exe.\n\n\nRun your command...\n\n\ninengine.exe -pMyCommandPlugin my-command\n\n\n\n\n\nDiscover Command Plugins\n\n\nRun inengine.exe without any arguments to see a list of plugins.\n\n\n  ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | || \n_ \\|  _| | \n_ \\ / _` | | \n_ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nUsage:\n  -p[\nplugin_name\n] [\ncommand_name\n]\n\nPlugins:\n  InEngine.Commands\n  InEngine.Core\n\n\n\n\n\nDiscover Commands in a Plugin\n\n\nRun inengine.exe with only the plugin specified.\n\n\ninengine.exe -pInEngine.Core\n\n\n\n\n\nThe \nInEngine.Core\n library is itself a plugin that contains queue related commands. \nAs an example, this is the help output for the core plugin.\n\n\n  ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | || \n_ \\|  _| | \n_ \\ / _` | | \n_ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nPlugin: InEngine.Core\n\nCommands:\n  null  A null operation command. Literally does nothing.\n  echo  Echo some text to the console. Useful for end-to-end testing.\n  queue:publish Publish a command message to a queue.\n  queue:consume Consume one or more command messages from the queue.\n  queue:length  Get the number of messages in the primary and secondary queues.\n  queue:clear   Clear the primary and secondary queues.\n\n\n\n\n\nPrint Help Text for a Plugin's Commands\n\n\nRun the command with the -h or --help arguments.\n\n\ninengine.exe -pInEngine.Core queue:clear -h\n\n\n\n\n\nThe \nInEngine.Core\n plugin's command to clear the InEngine.NET queues produces this help message. \n\n\nInEngine 3.x\nCopyright \u00a9 Ethan Hann 2017\n\n  --processing-queue    Clear the processing queue.\n\n  --secondary           Clear the secondary queue.\n\n\n\n\n\nWriting Output\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides some helper functions to output text to the console: \n\n\nIWrite\n \nNewline\n();\n\n\nIWrite\n \nInfo\n(\nstring\n \nval\n);\n\n\nIWrite\n \nWarning\n(\nstring\n \nval\n);\n\n\nIWrite\n \nError\n(\nstring\n \nval\n);\n\n\nIWrite\n \nLine\n(\nstring\n \nval\n);\n\n\n\n\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \nInfo\n(\nDisplay some information\n);\n\n\n}\n\n\n\n\n\n\nDisplay an error message, use the Error method.\n\n\nError\n(\nDisplay some information\n);\n\n\n\n\n\n\nDisplay a warning message, use the Warning method.\n\n\nError\n(\nDisplay some information\n);\n\n\n\n\n\n\nInfo, Error, and Warning messages are display in green, red, and yellow, respectively.\nIf you want to display an uncolored line, use the Line method. \nLine(\"This is a plain line.\");\n\n\nLogging\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides a Logger property. It implements the \nNLog.ILogger\n interface.\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \nLogger\n.\nTrace\n(\nSample trace message\n);\n\n    \nLogger\n.\nDebug\n(\nSample debug message\n);\n\n    \nLogger\n.\nInfo\n(\nSample informational message\n);\n\n    \nLogger\n.\nWarn\n(\nSample warning message\n);\n\n    \nLogger\n.\nError\n(\nSample error message\n);\n\n    \nLogger\n.\nFatal\n(\nSample fatal error message\n);\n\n    \nreturn\n \nnew\n \nvoid\n(\ntrue\n);\n\n\n}\n\n\n\n\n\n\nSetup an \nNLog configuration\n file, something like this...\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nnlog\n \nxmlns=\nhttp://www.nlog-project.org/schemas/NLog.xsd\n\n      \nxmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n\n    \ntargets\n\n        \ntarget\n \nname=\nlogfile\n \nxsi:type=\nFile\n \nfileName=\nfile.txt\n \n/\n\n        \ntarget\n \nname=\nconsole\n \nxsi:type=\nConsole\n \n/\n\n    \n/targets\n\n\n    \nrules\n\n        \nlogger\n \nname=\n*\n \nminlevel=\nTrace\n \nwriteTo=\nlogfile\n \n/\n\n        \nlogger\n \nname=\n*\n \nminlevel=\nInfo\n \nwriteTo=\nconsole\n \n/\n\n    \n/rules\n\n\n/nlog\n\n\n\n\n\n\nProgress Bar\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides a ProgressBar property. This is how it is used.\n\n\npublic\n \noverride\n \nvoid\n \nRun\n()\n\n\n{\n\n    \n// Define the ticks (aka steps) for the command...\n\n    \nvar\n \nmaxTicks\n \n=\n \n100000\n;\n\n    \nSetProgressBarMaxTicks\n(\nmaxTicks\n);\n\n\n    \n// Do some work...\n\n    \nfor\n \n(\nvar\n \ni\n \n=\n \n0\n;\n \ni\n \n=\n \nmaxTicks\n;\ni\n++)\n\n    \n{\n\n        \n// Update the command\ns progress\n\n        \nUpdateProgress\n(\ni\n);\n\n    \n}\n\n\n    \nreturn\n \nnew\n \nvoid\n(\ntrue\n);\n\n\n}", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#commands", 
            "text": "Commands are the fundamental abstraction used to run custom logic.", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#create-a-command", 
            "text": "The InEngine.Core package is required. Install it into your own Visual Studio project.  Package Manager  Install-Package InEngine.Core  Nuget CLI  nuget install InEgine.Core  .NET CLI  dotnet add package InEngine.Core  Paket CLI  paket add InEngine.Core  Adding a class that implements  InEngine.Core.ICommand  is the simplest way to create a command.  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   ICommand \n     { \n         public   void   Run () \n         { \n             Console . WriteLine ( Hello, world! ); \n             return   new   void ( true ); \n         } \n     }  }   Extending the  InEngine.Core.AbstractCommand  class adds extra functionality, like a logger, a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.  using   System ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyCommand   :   AbstractCommand \n     { \n         public   override   void   Run () \n         { \n             Console . WriteLine ( Hello, world! ); \n             return   new   void ( true ); \n         } \n     }  }", 
            "title": "Create a Command"
        }, 
        {
            "location": "/commands/#run-a-command", 
            "text": "Create a class that implements  InEngine.Core.IOptions  in the same assembly as the command class.\nAdd a VerbOptions attribute from the CommandLine namespace that defines the name of the command and optional help text.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method.    using   CommandLine ;  using   CommandLine.Text ;  using   InEngine.Core ;  namespace   MyCommandPlugin  { \n     public   class   MyOptions   :   IOptions \n     {          [VerbOption( my-command , HelpText= My example command. )] \n         public   MyCommand   MyCommand   {   get ;   set ;   }          [HelpVerbOption] \n         public   string   GetUsage ( string   verb ) \n         { \n             return   HelpText . AutoBuild ( this ,   verb ); \n         } \n     }  }   Download the InEngine binary distribution, from the  GitHub Releases  page, that matches the version of the InEngine.Core package you included.  Copy your project's DLLs into the same directory as inengine.exe.  Run your command...  inengine.exe -pMyCommandPlugin my-command", 
            "title": "Run a Command"
        }, 
        {
            "location": "/commands/#discover-command-plugins", 
            "text": "Run inengine.exe without any arguments to see a list of plugins.    ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | ||  _ \\|  _| |  _ \\ / _` | |  _ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nUsage:\n  -p[ plugin_name ] [ command_name ]\n\nPlugins:\n  InEngine.Commands\n  InEngine.Core", 
            "title": "Discover Command Plugins"
        }, 
        {
            "location": "/commands/#discover-commands-in-a-plugin", 
            "text": "Run inengine.exe with only the plugin specified.  inengine.exe -pInEngine.Core  The  InEngine.Core  library is itself a plugin that contains queue related commands. \nAs an example, this is the help output for the core plugin.    ___       _____             _              _   _ _____ _____ \n |_ _|_ __ | ____|_ __   __ _(_)_ __   ___  | \\ | | ____|_   _|\n  | ||  _ \\|  _| |  _ \\ / _` | |  _ \\ / _ \\ |  \\| |  _|   | |  \n  | || | | | |___| | | | (_| | | | | |  __/_| |\\  | |___  | |  \n |___|_| |_|_____|_| |_|\\__, |_|_| |_|\\___(_|_| \\_|_____| |_|  \n                        |___/ \n\nPlugin: InEngine.Core\n\nCommands:\n  null  A null operation command. Literally does nothing.\n  echo  Echo some text to the console. Useful for end-to-end testing.\n  queue:publish Publish a command message to a queue.\n  queue:consume Consume one or more command messages from the queue.\n  queue:length  Get the number of messages in the primary and secondary queues.\n  queue:clear   Clear the primary and secondary queues.", 
            "title": "Discover Commands in a Plugin"
        }, 
        {
            "location": "/commands/#print-help-text-for-a-plugins-commands", 
            "text": "Run the command with the -h or --help arguments.  inengine.exe -pInEngine.Core queue:clear -h  The  InEngine.Core  plugin's command to clear the InEngine.NET queues produces this help message.   InEngine 3.x\nCopyright \u00a9 Ethan Hann 2017\n\n  --processing-queue    Clear the processing queue.\n\n  --secondary           Clear the secondary queue.", 
            "title": "Print Help Text for a Plugin's Commands"
        }, 
        {
            "location": "/commands/#writing-output", 
            "text": "The  InEngine.Core.AbstractCommand  class provides some helper functions to output text to the console:   IWrite   Newline ();  IWrite   Info ( string   val );  IWrite   Warning ( string   val );  IWrite   Error ( string   val );  IWrite   Line ( string   val );   public   override   void   Run ()  { \n     Info ( Display some information );  }   Display an error message, use the Error method.  Error ( Display some information );   Display a warning message, use the Warning method.  Error ( Display some information );   Info, Error, and Warning messages are display in green, red, and yellow, respectively.\nIf you want to display an uncolored line, use the Line method. \nLine(\"This is a plain line.\");", 
            "title": "Writing Output"
        }, 
        {
            "location": "/commands/#logging", 
            "text": "The  InEngine.Core.AbstractCommand  class provides a Logger property. It implements the  NLog.ILogger  interface.  public   override   void   Run ()  { \n     Logger . Trace ( Sample trace message ); \n     Logger . Debug ( Sample debug message ); \n     Logger . Info ( Sample informational message ); \n     Logger . Warn ( Sample warning message ); \n     Logger . Error ( Sample error message ); \n     Logger . Fatal ( Sample fatal error message ); \n     return   new   void ( true );  }   Setup an  NLog configuration  file, something like this...  ?xml version= 1.0  encoding= utf-8  ?  nlog   xmlns= http://www.nlog-project.org/schemas/NLog.xsd \n       xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n\n     targets \n         target   name= logfile   xsi:type= File   fileName= file.txt   / \n         target   name= console   xsi:type= Console   / \n     /targets \n\n     rules \n         logger   name= *   minlevel= Trace   writeTo= logfile   / \n         logger   name= *   minlevel= Info   writeTo= console   / \n     /rules  /nlog", 
            "title": "Logging"
        }, 
        {
            "location": "/commands/#progress-bar", 
            "text": "The  InEngine.Core.AbstractCommand  class provides a ProgressBar property. This is how it is used.  public   override   void   Run ()  { \n     // Define the ticks (aka steps) for the command... \n     var   maxTicks   =   100000 ; \n     SetProgressBarMaxTicks ( maxTicks ); \n\n     // Do some work... \n     for   ( var   i   =   0 ;   i   =   maxTicks ; i ++) \n     { \n         // Update the command s progress \n         UpdateProgress ( i ); \n     } \n\n     return   new   void ( true );  }", 
            "title": "Progress Bar"
        }, 
        {
            "location": "/scheduling/", 
            "text": "Scheduling\n\n\nCommands\n can be scheduled to run by leveraging the inengine.exe program, available as a download from a recent \nrelease\n.\n\n\nScheduling a Command\n\n\nA job schedule is created by adding a class to your plugin assembly that implements the \nInEngine.Core.Jobs\n interface.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nQuartz\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nJobs\n \n:\n \nIJobs\n\n    \n{\n\n        \npublic\n \nvoid\n \nSchedule\n(\nIScheduler\n \nscheduler\n)\n\n        \n{\n\n            \n// Schedule some jobs\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThis class is automatically discovered by the InEngine.NET scheduler.\nIt will call the Jobs.Schedule method with an initialized Quartz.NET scheduler object.\n\n\nusing\n \nSystem\n;\n\n\nusing\n \nQuartz\n;\n\n\n\nnamespace\n \nMyCommandPlugin\n\n\n{\n\n    \npublic\n \nclass\n \nJobs\n \n:\n \nIJobs\n\n    \n{\n\n        \npublic\n \nvoid\n \nSchedule\n(\nIScheduler\n \nscheduler\n)\n\n        \n{\n\n            \nvar\n \nmyCommand\n \n=\n \nnew\n \nMyCommand\n();\n\n\n            \n// Generate a schedulable job with the command.\n\n            \nvar\n \njob\n \n=\n \nmyCommand\n.\nMakeTriggerBuilder\n().\nBuild\n();\n\n\n            \n// Generate a trigger for the job, and set its schedule to every 10 seconds.\n\n            \nvar\n \ntrigger\n \n=\n \nmyCommand\n.\nMakeTriggerBuilder\n().\nBuild\n()\n\n                \n.\nStartNow\n()\n\n                \n.\nWithSimpleSchedule\n(\nx\n \n=\n \nx\n.\nWithIntervalInSeconds\n(\n10\n).\nRepeatForever\n())\n\n                \n.\nBuild\n();\n\n\n            \n// Register the job and trigger with the scheduler.\n\n            \nscheduler\n.\nScheduleJob\n(\njob\n,\n \ntrigger\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nRunning the Scheduler\n\n\nManually from the CLI\n\n\nRunning the scheduler from the CommandLine is useful for debugging or local development. Simply run \ninengine.exe\n from the command line.\n\n\ninengine.exe\n\n\n\n\n\nIt can also be run on Mac/Linux with Mono.\n\n\nmono inengine.exe\n\n\n\n\n\nOn Windows as a Service\n\n\nInstalling\n\n\nRun the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. The script needs to be run as an administrator. The script will register the service at the location where the script is run. \n\n\nps Install.ps1\n\n\n\n\n\nUninstalling\n\n\nSimply run the \nUninstall.ps1\n script with elevated permissions to unregister the service.\n\n\nps Uninstall.ps1\n\n\n\n\n\nOn Linux with Supervisor\n\n\nSupervisor is a process control system for Linux. It has extensive \ndocumentation\n, but the following should be enough to get started.\n\n\nInstalling Supervisor\n\n\nThis command installs Supervisor on Ubuntu:\n\n\nsudo apt-get install supervisor\n\n\n\n\n\nConfiguring Supervisor\n\n\nSupervisor configuration files are stored in the \n/etc/supervisor/conf.d\n directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called \n/etc/supervisor/conf.d/inengine-scheduler.conf\n. \n\n\n[program:inengine-scheudler]\n\n\nprocess_name\n=\n%(program_name)s_%(process_num)02d\n\n\ndirectory\n=\n/path/to/scheduler\n\n\ncommand\n=\nmono inengine.exe\n\n\nautostart\n=\ntrue\n\n\nautorestart\n=\ntrue\n\n\nuser\n=\nInEngine\n\n\nnumprocs\n=\n1\n\n\nredirect_stderr\n=\ntrue\n\n\nstdout_logfile\n=\n./scheduler.log\n\n\n\n\n\n\nStarting Supervisor\n\n\nWhenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.\n\n\nsudo supervisorctl reread\nsudo supervisorctl update\n\n\n\n\n\nNow, simply start the InEngine Scheduler.\n\n\nsudo supervisorctl start inengine-scheduler:*", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling", 
            "text": "Commands  can be scheduled to run by leveraging the inengine.exe program, available as a download from a recent  release .", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling-a-command", 
            "text": "A job schedule is created by adding a class to your plugin assembly that implements the  InEngine.Core.Jobs  interface.  using   System ;  using   Quartz ;  namespace   MyCommandPlugin  { \n     public   class   Jobs   :   IJobs \n     { \n         public   void   Schedule ( IScheduler   scheduler ) \n         { \n             // Schedule some jobs \n         } \n     }  }   This class is automatically discovered by the InEngine.NET scheduler.\nIt will call the Jobs.Schedule method with an initialized Quartz.NET scheduler object.  using   System ;  using   Quartz ;  namespace   MyCommandPlugin  { \n     public   class   Jobs   :   IJobs \n     { \n         public   void   Schedule ( IScheduler   scheduler ) \n         { \n             var   myCommand   =   new   MyCommand (); \n\n             // Generate a schedulable job with the command. \n             var   job   =   myCommand . MakeTriggerBuilder (). Build (); \n\n             // Generate a trigger for the job, and set its schedule to every 10 seconds. \n             var   trigger   =   myCommand . MakeTriggerBuilder (). Build () \n                 . StartNow () \n                 . WithSimpleSchedule ( x   =   x . WithIntervalInSeconds ( 10 ). RepeatForever ()) \n                 . Build (); \n\n             // Register the job and trigger with the scheduler. \n             scheduler . ScheduleJob ( job ,   trigger ); \n         } \n     }  }", 
            "title": "Scheduling a Command"
        }, 
        {
            "location": "/scheduling/#running-the-scheduler", 
            "text": "", 
            "title": "Running the Scheduler"
        }, 
        {
            "location": "/scheduling/#manually-from-the-cli", 
            "text": "Running the scheduler from the CommandLine is useful for debugging or local development. Simply run  inengine.exe  from the command line.  inengine.exe  It can also be run on Mac/Linux with Mono.  mono inengine.exe", 
            "title": "Manually from the CLI"
        }, 
        {
            "location": "/scheduling/#on-windows-as-a-service", 
            "text": "", 
            "title": "On Windows as a Service"
        }, 
        {
            "location": "/scheduling/#installing", 
            "text": "Run the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. The script needs to be run as an administrator. The script will register the service at the location where the script is run.   ps Install.ps1", 
            "title": "Installing"
        }, 
        {
            "location": "/scheduling/#uninstalling", 
            "text": "Simply run the  Uninstall.ps1  script with elevated permissions to unregister the service.  ps Uninstall.ps1", 
            "title": "Uninstalling"
        }, 
        {
            "location": "/scheduling/#on-linux-with-supervisor", 
            "text": "Supervisor is a process control system for Linux. It has extensive  documentation , but the following should be enough to get started.", 
            "title": "On Linux with Supervisor"
        }, 
        {
            "location": "/scheduling/#installing-supervisor", 
            "text": "This command installs Supervisor on Ubuntu:  sudo apt-get install supervisor", 
            "title": "Installing Supervisor"
        }, 
        {
            "location": "/scheduling/#configuring-supervisor", 
            "text": "Supervisor configuration files are stored in the  /etc/supervisor/conf.d  directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called  /etc/supervisor/conf.d/inengine-scheduler.conf .   [program:inengine-scheudler]  process_name = %(program_name)s_%(process_num)02d  directory = /path/to/scheduler  command = mono inengine.exe  autostart = true  autorestart = true  user = InEngine  numprocs = 1  redirect_stderr = true  stdout_logfile = ./scheduler.log", 
            "title": "Configuring Supervisor"
        }, 
        {
            "location": "/scheduling/#starting-supervisor", 
            "text": "Whenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.  sudo supervisorctl reread\nsudo supervisorctl update  Now, simply start the InEngine Scheduler.  sudo supervisorctl start inengine-scheduler:*", 
            "title": "Starting Supervisor"
        }, 
        {
            "location": "/queuing/", 
            "text": "Queuing\n\n\nPrerequisites\n\n\nRedis is required to use the InEngine.NET Queue feature. \nIt can be installed on Ubuntu with this command:\n\n\nsudo apt-get install redis-server\n\n\n\n\n\nStart Redis with this command:\n\n\nsudo service redis start\n\n\n\n\n\n\nIt is highly recommended to \nset a password\n for Redis.\n\n\n\n\nWorking with Queues\n\n\nPublishing Commands\n\n\nProgrammatically\n\n\nCommands\n can be published programmatically with the \nInEngine.Core.Queue.Broker\n class:\n\n\nBroker\n.\nMake\n().\nPublish\n(\nnew\n \nMyCommand\n());\n\n\n\n\n\n\nFrom the Command Line\n\n\nCommands can be published from the command line as well.\nNote that all queue commands reside in the \nInEngine.Core\n plugin.\nThis is an example of how to publish a command from the CLI by specifying the commands assembly, class name, and arguments:\n\n\ninengine.exe -pInEngine.Core queue:publish --command-assembly\n=\nMyCommandPlugin.dll --command-class\n=\nMyCommand --args \ntext=bar\n\n\n\n\n\n\nThere is an \"Echo\" command in the \nInEngine.Core\n package. It is useful for end-to-end testing with the queue feature.\n\n\ninengine.exe -pInEngine.Core queue:publish --command-assembly\n=\nInEngine.Core.dll --command-class\n=\nInEngine.Core.Commands.Echo --args \ntext=foo\n\n\n\n\n\n\nConsuming Commands\n\n\nProgrammatically\n\n\nConsuming a command is also accomplished with the Broker class:\n\n\nBroker\n.\nMake\n().\nConsume\n();\n\n\n\n\n\n\nBoth methods take an optional second argument to indicate if the secondary queue should be used instead of the primary queue.\n\n\n// Uses secondary queue.\n\n\nBroker\n.\nMake\n().\nConsume\n(\ntrue\n);\n\n\n\n\n\n\nCommands can be consumed from the command line as well with this simple command:\n\n\nFrom the Command Line\n\n\ninengine.exe -pInEngine.Core queue:consume\n\n\n\n\n\nUse the \n--secondary\n switch to consume the secondary queue instead of the primary queue:\n\n\ninengine.exe -pInEngine.Core queue:consume --secondary\n\n\n\n\n\nWith the Scheduler\n\n\nThe InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of \nways to run the scheduler\n.\n\n\nPrimary and Secondary Queue\n\n\nOther than the fact that the primary queue is used by default, there is difference between the primary and secondary queues. \nHowever, it is often desirable to have more than 1 queue. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.\n\n\nWhat about 3, 4, or 900 queues? Numerous queues gets to be a pain to manage and, practically speaking, is probably unnecessary.\nIf it is desirable, different \nconfiguration files\n can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#queuing", 
            "text": "", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#prerequisites", 
            "text": "Redis is required to use the InEngine.NET Queue feature. \nIt can be installed on Ubuntu with this command:  sudo apt-get install redis-server  Start Redis with this command:  sudo service redis start  \nIt is highly recommended to  set a password  for Redis.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/queuing/#working-with-queues", 
            "text": "", 
            "title": "Working with Queues"
        }, 
        {
            "location": "/queuing/#publishing-commands", 
            "text": "", 
            "title": "Publishing Commands"
        }, 
        {
            "location": "/queuing/#programmatically", 
            "text": "Commands  can be published programmatically with the  InEngine.Core.Queue.Broker  class:  Broker . Make (). Publish ( new   MyCommand ());", 
            "title": "Programmatically"
        }, 
        {
            "location": "/queuing/#from-the-command-line", 
            "text": "Commands can be published from the command line as well.\nNote that all queue commands reside in the  InEngine.Core  plugin.\nThis is an example of how to publish a command from the CLI by specifying the commands assembly, class name, and arguments:  inengine.exe -pInEngine.Core queue:publish --command-assembly = MyCommandPlugin.dll --command-class = MyCommand --args  text=bar   There is an \"Echo\" command in the  InEngine.Core  package. It is useful for end-to-end testing with the queue feature.  inengine.exe -pInEngine.Core queue:publish --command-assembly = InEngine.Core.dll --command-class = InEngine.Core.Commands.Echo --args  text=foo", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#consuming-commands", 
            "text": "", 
            "title": "Consuming Commands"
        }, 
        {
            "location": "/queuing/#programmatically_1", 
            "text": "Consuming a command is also accomplished with the Broker class:  Broker . Make (). Consume ();   Both methods take an optional second argument to indicate if the secondary queue should be used instead of the primary queue.  // Uses secondary queue.  Broker . Make (). Consume ( true );   Commands can be consumed from the command line as well with this simple command:", 
            "title": "Programmatically"
        }, 
        {
            "location": "/queuing/#from-the-command-line_1", 
            "text": "inengine.exe -pInEngine.Core queue:consume  Use the  --secondary  switch to consume the secondary queue instead of the primary queue:  inengine.exe -pInEngine.Core queue:consume --secondary", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#with-the-scheduler", 
            "text": "The InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of  ways to run the scheduler .", 
            "title": "With the Scheduler"
        }, 
        {
            "location": "/queuing/#primary-and-secondary-queue", 
            "text": "Other than the fact that the primary queue is used by default, there is difference between the primary and secondary queues. \nHowever, it is often desirable to have more than 1 queue. \nFor example, long running jobs might be sent to the secondary queue, \nwhile jobs that are expected to finish after only a few moments are sent to the primary queue.  What about 3, 4, or 900 queues? Numerous queues gets to be a pain to manage and, practically speaking, is probably unnecessary.\nIf it is desirable, different  configuration files  can be used to run multiple instances of InEngine.NET.\nSimply create a new config file with a new QueueName setting and point inengine.exe at it.", 
            "title": "Primary and Secondary Queue"
        }, 
        {
            "location": "/configuration/", 
            "text": "Configuration\n\n\nConfiguration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution. The -c, --configuration argument can also be used to specify an alternate configuration file.\n\n\n{\n\n  \nInEngine\n:\n \n{\n\n    \nQueue\n:\n \n{\n\n      \nPrimaryQueueConsumers\n:\n  \n16\n,\n\n      \nSecondaryQueueConsumers\n:\n \n4\n,\n\n      \nQueueName\n:\n \nInEngine:Queue\n,\n\n      \nRedisHost\n:\n \nlocalhost\n,\n\n      \nRedisPort\n:\n \n6379\n,\n\n      \nRedisDb\n:\n \n0\n,\n\n      \nRedisPassword\n:\n \n\n    \n}\n\n  \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nSetting\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nPrimaryQueueConsumers\n\n\nThe number of consumers to schedule for the primary queue.\n\n\n\n\n\n\nSecondaryQueueConsumers\n\n\nThe number of consumers to schedule for the secondary queue.\n\n\n\n\n\n\nQueueName\n\n\nThe base name of the queue, used to form the Redis Queue keys.\n\n\n\n\n\n\nRedisHost\n\n\nThe Redis hostname to connect to.\n\n\n\n\n\n\nRedisPort\n\n\nRedis's port.\n\n\n\n\n\n\nRedisDb\n\n\nThe Redis database - 0-15\n\n\n\n\n\n\nRedisPassword\n\n\nThe Redis auth password", 
            "title": "Configuration"
        }, 
        {
            "location": "/configuration/#configuration", 
            "text": "Configuration is accomplished by modifying the appsettings.json file that comes with the InEngine.NET binary distribution. The -c, --configuration argument can also be used to specify an alternate configuration file.  { \n   InEngine :   { \n     Queue :   { \n       PrimaryQueueConsumers :    16 , \n       SecondaryQueueConsumers :   4 , \n       QueueName :   InEngine:Queue , \n       RedisHost :   localhost , \n       RedisPort :   6379 , \n       RedisDb :   0 , \n       RedisPassword :   \n     } \n   }  }      Setting  Description      PrimaryQueueConsumers  The number of consumers to schedule for the primary queue.    SecondaryQueueConsumers  The number of consumers to schedule for the secondary queue.    QueueName  The base name of the queue, used to form the Redis Queue keys.    RedisHost  The Redis hostname to connect to.    RedisPort  Redis's port.    RedisDb  The Redis database - 0-15    RedisPassword  The Redis auth password", 
            "title": "Configuration"
        }
    ]
}