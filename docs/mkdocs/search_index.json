{
    "docs": [
        {
            "location": "/", 
            "text": "InEngine.NET - Command Processing Server.\n\n\nInEngine.NET allows commands to be queued, scheduled, and run directly. \n\n\nHow to Get Started\n\n\nGet started by reading up on \ncommands\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#inenginenet-command-processing-server", 
            "text": "InEngine.NET allows commands to be queued, scheduled, and run directly.", 
            "title": "InEngine.NET - Command Processing Server."
        }, 
        {
            "location": "/#how-to-get-started", 
            "text": "Get started by reading up on  commands .", 
            "title": "How to Get Started"
        }, 
        {
            "location": "/commands/", 
            "text": "Commands\n\n\nCommands are the fundamental abstraction used to run custom logic.\n\n\nCreate a Command\n\n\nThe InEngine.Core package is required. Install it into your own Visual Studio project.\n\n\nPackage Manager\n\n\nInstall-Package InEngine.Core\n\n\n\n\nNuget CLI\n\n\nnuget install InEgine.Core\n\n\n\n\n.NET CLI\n\n\ndotnet add package InEngine.Core\n\n\n\n\nPaket CLI\n\n\npaket add InEngine.Core\n\n\n\n\nAdding a class that implements \nInEngine.Core.ICommand\n is the simplest way to create a command.\n\n\nusing System;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : ICommand\n    {\n        public CommandResult Run()\n        {\n            Console.WriteLine(\nHello, world!\n);\n            return new CommandResult(true);\n        }\n    }\n}\n\n\n\n\nExtending the \nInEngine.Core.AbstractCommand\n class adds extra functionality, like a logger, a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.\n\n\nusing System;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : ICommand\n    {\n        public override CommandResult Run()\n        {\n            Console.WriteLine(\nHello, world!\n);\n            return new CommandResult(true);\n        }\n    }\n}\n\n\n\n\nRun a Command\n\n\nCreate a class that implements \nInEngine.Core.IOptions\n in the same assembly as the command class.\nAdd a VerbOptions attribute from the CommandLine namespace that defines the name of the command and optional help text.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method.  \n\n\nusing CommandLine;\nusing CommandLine.Text;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyOptions : IOptions\n    {\n        [VerbOption(\nmy-command\n, HelpText=\nMy example command.\n)]\n        public MyCommand MyCommand { get; set; }\n\n        [HelpVerbOption]\n        public string GetUsage(string verb)\n        {\n            return HelpText.AutoBuild(this, verb);\n        }\n    }\n}\n\n\n\n\nDownload the InEngineCli tool that matches the version of the InEngine.Core package you included from the \nGitHub Releases\n page.\n\n\nCopy your project's DLLs into the same directory as InEngineCli.exe.\n\n\nRun your command...\n\n\nInEngineCli.exe -pMyCommandPlugin my-command\n\n\n\n\nDiscover Command Plugins\n\n\nRun InEngineCli.exe without any arguments to see a list of arguments.\n\n\nAvailable plugins... \nInEngine.Commands\nInEngine.Core\n\n\n\n\nDiscover Commands in a Plugin\n\n\nRun InEngineCli.exe with only the plugin specified.\n\n\nInEngineCli.exe -pInEngine.Core\n\n\n\n\nThe \nInEngine.Core\n library is itself a plugin that contains queue related commands. \nAs an example, this is the help output for the core plugin.\n\n\nInEngine 3.x\nCopyright \u00a9 Ethan Hann 2017\n\n  queue:publish    Publish a command message to a queue.\n\n  queue:consume    Consume one or more command messages from the queue.\n\n  queue:length     Get the number of messages in the primary and secondary \n                   queues.\n\n  queue:clear      Clear the primary and secondary queues.\n\n\n\n\nPrint Help Text for a Plugin's Commands\n\n\nRun the command with the -h or --help arguments.\n\n\nInEngineCli.exe -pInEngine.Core queue:clear -h\n\n\n\n\nThe \nInEngine.Core\n plugin's command to clear the InEngine.NET's queues produces this help message. \n\n\nInEngine 3.x\nCopyright \u00a9 Ethan Hann 2017\n\n  --processing-queue    Clear the processing queue.\n\n  --secondary           Clear the secondary queue.\n\n\n\n\nLogging\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides a Logger property. It implements the \nNLog.ILogger\n interface.\n\n\nusing System;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : ICommand\n    {\n        public override CommandResult Run()\n        {\n            Logger.Trace(\nSample trace message\n);\n            Logger.Debug(\nSample debug message\n);\n            Logger.Info(\nSample informational message\n);\n            Logger.Warn(\nSample warning message\n);\n            Logger.Error(\nSample error message\n);\n            Logger.Fatal(\nSample fatal error message\n);\n            return new CommandResult(true);\n        }\n    }\n}\n\n\n\n\nSetup an \nNLog configuration\n file, something like this...\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n ?\n\n\nnlog xmlns=\nhttp://www.nlog-project.org/schemas/NLog.xsd\n\n      xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n\n    \ntargets\n\n        \ntarget name=\nlogfile\n xsi:type=\nFile\n fileName=\nfile.txt\n /\n\n        \ntarget name=\nconsole\n xsi:type=\nConsole\n /\n\n    \n/targets\n\n\n    \nrules\n\n        \nlogger name=\n*\n minlevel=\nTrace\n writeTo=\nlogfile\n /\n\n        \nlogger name=\n*\n minlevel=\nInfo\n writeTo=\nconsole\n /\n\n    \n/rules\n\n\n/nlog\n\n\n\n\n\nProgress Bar\n\n\nThe \nInEngine.Core.AbstractCommand\n class provides a ProgressBar property. This is how it is used.\n\n\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : AbstractCommand\n    {\n        public override CommandResult Run()\n        {\n            // Define the ticks (aka steps) for the command...\n            var maxTicks = 100000;\n            SetProgressBarMaxTicks(maxTicks);\n\n            // Do some work...\n            for (var i = 0; i \n= maxTicks;i++)\n            {\n                // Update the command's progress\n                UpdateProgress(i);\n            }\n\n            return new CommandResult(true);\n        }\n    }\n}", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#commands", 
            "text": "Commands are the fundamental abstraction used to run custom logic.", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#create-a-command", 
            "text": "The InEngine.Core package is required. Install it into your own Visual Studio project.  Package Manager  Install-Package InEngine.Core  Nuget CLI  nuget install InEgine.Core  .NET CLI  dotnet add package InEngine.Core  Paket CLI  paket add InEngine.Core  Adding a class that implements  InEngine.Core.ICommand  is the simplest way to create a command.  using System;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : ICommand\n    {\n        public CommandResult Run()\n        {\n            Console.WriteLine( Hello, world! );\n            return new CommandResult(true);\n        }\n    }\n}  Extending the  InEngine.Core.AbstractCommand  class adds extra functionality, like a logger, a progress bar, and the ability to schedule the command using the scheduler.\nMinimally, the Run method should be overridden.  using System;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : ICommand\n    {\n        public override CommandResult Run()\n        {\n            Console.WriteLine( Hello, world! );\n            return new CommandResult(true);\n        }\n    }\n}", 
            "title": "Create a Command"
        }, 
        {
            "location": "/commands/#run-a-command", 
            "text": "Create a class that implements  InEngine.Core.IOptions  in the same assembly as the command class.\nAdd a VerbOptions attribute from the CommandLine namespace that defines the name of the command and optional help text.\nThe help text can be auto-generated from the attribute or manually specified in the GetUsage method.    using CommandLine;\nusing CommandLine.Text;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyOptions : IOptions\n    {\n        [VerbOption( my-command , HelpText= My example command. )]\n        public MyCommand MyCommand { get; set; }\n\n        [HelpVerbOption]\n        public string GetUsage(string verb)\n        {\n            return HelpText.AutoBuild(this, verb);\n        }\n    }\n}  Download the InEngineCli tool that matches the version of the InEngine.Core package you included from the  GitHub Releases  page.  Copy your project's DLLs into the same directory as InEngineCli.exe.  Run your command...  InEngineCli.exe -pMyCommandPlugin my-command", 
            "title": "Run a Command"
        }, 
        {
            "location": "/commands/#discover-command-plugins", 
            "text": "Run InEngineCli.exe without any arguments to see a list of arguments.  Available plugins... \nInEngine.Commands\nInEngine.Core", 
            "title": "Discover Command Plugins"
        }, 
        {
            "location": "/commands/#discover-commands-in-a-plugin", 
            "text": "Run InEngineCli.exe with only the plugin specified.  InEngineCli.exe -pInEngine.Core  The  InEngine.Core  library is itself a plugin that contains queue related commands. \nAs an example, this is the help output for the core plugin.  InEngine 3.x\nCopyright \u00a9 Ethan Hann 2017\n\n  queue:publish    Publish a command message to a queue.\n\n  queue:consume    Consume one or more command messages from the queue.\n\n  queue:length     Get the number of messages in the primary and secondary \n                   queues.\n\n  queue:clear      Clear the primary and secondary queues.", 
            "title": "Discover Commands in a Plugin"
        }, 
        {
            "location": "/commands/#print-help-text-for-a-plugins-commands", 
            "text": "Run the command with the -h or --help arguments.  InEngineCli.exe -pInEngine.Core queue:clear -h  The  InEngine.Core  plugin's command to clear the InEngine.NET's queues produces this help message.   InEngine 3.x\nCopyright \u00a9 Ethan Hann 2017\n\n  --processing-queue    Clear the processing queue.\n\n  --secondary           Clear the secondary queue.", 
            "title": "Print Help Text for a Plugin's Commands"
        }, 
        {
            "location": "/commands/#logging", 
            "text": "The  InEngine.Core.AbstractCommand  class provides a Logger property. It implements the  NLog.ILogger  interface.  using System;\nusing InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : ICommand\n    {\n        public override CommandResult Run()\n        {\n            Logger.Trace( Sample trace message );\n            Logger.Debug( Sample debug message );\n            Logger.Info( Sample informational message );\n            Logger.Warn( Sample warning message );\n            Logger.Error( Sample error message );\n            Logger.Fatal( Sample fatal error message );\n            return new CommandResult(true);\n        }\n    }\n}  Setup an  NLog configuration  file, something like this...  ?xml version= 1.0  encoding= utf-8  ?  nlog xmlns= http://www.nlog-project.org/schemas/NLog.xsd \n      xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n\n     targets \n         target name= logfile  xsi:type= File  fileName= file.txt  / \n         target name= console  xsi:type= Console  / \n     /targets \n\n     rules \n         logger name= *  minlevel= Trace  writeTo= logfile  / \n         logger name= *  minlevel= Info  writeTo= console  / \n     /rules  /nlog", 
            "title": "Logging"
        }, 
        {
            "location": "/commands/#progress-bar", 
            "text": "The  InEngine.Core.AbstractCommand  class provides a ProgressBar property. This is how it is used.  using InEngine.Core;\n\nnamespace MyCommandPlugin\n{\n    public class MyCommand : AbstractCommand\n    {\n        public override CommandResult Run()\n        {\n            // Define the ticks (aka steps) for the command...\n            var maxTicks = 100000;\n            SetProgressBarMaxTicks(maxTicks);\n\n            // Do some work...\n            for (var i = 0; i  = maxTicks;i++)\n            {\n                // Update the command's progress\n                UpdateProgress(i);\n            }\n\n            return new CommandResult(true);\n        }\n    }\n}", 
            "title": "Progress Bar"
        }, 
        {
            "location": "/scheduling/", 
            "text": "Scheduling\n\n\nCommands\n can be scheduled to run by leveraging the InEngineScheduler.exe program, available as a download from a recent \nrelease\n.\n\n\nRunning the Scheduler\n\n\nManually from the CLI\n\n\nRunning the scheduler from the CommandLine is useful for debugging or local development. Simply run \nInEngineScheduler.exe\n from the command line.\n\n\nInEngineScheduler.exe\n\n\n\n\nIt can also be run on Mac/Linux with Mono.\n\n\nmono InEngineScheduler.exe\n\n\n\n\nOn Windows as a Service\n\n\nInstalling\n\n\nRun the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. The script needs to be run as an administrator. The script will register the service at the location where the script is run. \n\n\nps Install.ps1\n\n\n\n\nUninstalling\n\n\nSimply run the \nUninstall.ps1\n script with elevated permissions to unregister the service.\n\n\nps Uninstall.ps1\n\n\n\n\nOn Linux with Supervisor\n\n\nSupervisor is a process control system for Linux. It has extensive \ndocumentation\n, but the following should be enough to get started.\n\n\nInstalling Supervisor\n\n\nThis command installs Supervisor on Ubuntu:\n\n\nsudo apt-get install supervisor\n\n\n\n\nConfiguring Supervisor\n\n\nSupervisor configuration files are stored in the \n/etc/supervisor/conf.d\n directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called \n/etc/supervisor/conf.d/inengine-scheduler.conf\n. \n\n\n[program:inengine-scheudler]\nprocess_name=%(program_name)s_%(process_num)02d\ndirectory=/path/to/scheduler\ncommand=mono InEngineScheduler.exe\nautostart=true\nautorestart=true\nuser=InEngine\nnumprocs=1\nredirect_stderr=true\nstdout_logfile=./scheduler.log\n\n\n\n\nStarting Supervisor\n\n\nWhenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.\n\n\nsudo supervisorctl reread\nsudo supervisorctl update\n\n\n\n\nNow, simply start the InEngine Scheduler.\n\n\nsudo supervisorctl start inengine-scheduler:*", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#scheduling", 
            "text": "Commands  can be scheduled to run by leveraging the InEngineScheduler.exe program, available as a download from a recent  release .", 
            "title": "Scheduling"
        }, 
        {
            "location": "/scheduling/#running-the-scheduler", 
            "text": "", 
            "title": "Running the Scheduler"
        }, 
        {
            "location": "/scheduling/#manually-from-the-cli", 
            "text": "Running the scheduler from the CommandLine is useful for debugging or local development. Simply run  InEngineScheduler.exe  from the command line.  InEngineScheduler.exe  It can also be run on Mac/Linux with Mono.  mono InEngineScheduler.exe", 
            "title": "Manually from the CLI"
        }, 
        {
            "location": "/scheduling/#on-windows-as-a-service", 
            "text": "", 
            "title": "On Windows as a Service"
        }, 
        {
            "location": "/scheduling/#installing", 
            "text": "Run the Install.ps1 PowerShell script in the scheduler directory to install the scheduler in place. The script needs to be run as an administrator. The script will register the service at the location where the script is run.   ps Install.ps1", 
            "title": "Installing"
        }, 
        {
            "location": "/scheduling/#uninstalling", 
            "text": "Simply run the  Uninstall.ps1  script with elevated permissions to unregister the service.  ps Uninstall.ps1", 
            "title": "Uninstalling"
        }, 
        {
            "location": "/scheduling/#on-linux-with-supervisor", 
            "text": "Supervisor is a process control system for Linux. It has extensive  documentation , but the following should be enough to get started.", 
            "title": "On Linux with Supervisor"
        }, 
        {
            "location": "/scheduling/#installing-supervisor", 
            "text": "This command installs Supervisor on Ubuntu:  sudo apt-get install supervisor", 
            "title": "Installing Supervisor"
        }, 
        {
            "location": "/scheduling/#configuring-supervisor", 
            "text": "Supervisor configuration files are stored in the  /etc/supervisor/conf.d  directory. Multiple files can be created in this directory to specify different programs, or multiple instances of the same program, for Supervisor to monitor. Copy this sample config into a file called  /etc/supervisor/conf.d/inengine-scheduler.conf .   [program:inengine-scheudler]\nprocess_name=%(program_name)s_%(process_num)02d\ndirectory=/path/to/scheduler\ncommand=mono InEngineScheduler.exe\nautostart=true\nautorestart=true\nuser=InEngine\nnumprocs=1\nredirect_stderr=true\nstdout_logfile=./scheduler.log", 
            "title": "Configuring Supervisor"
        }, 
        {
            "location": "/scheduling/#starting-supervisor", 
            "text": "Whenever a configuration change happens to files in the Supervisor config files, Supervisor needs to be instructed to reload its configuration.  sudo supervisorctl reread\nsudo supervisorctl update  Now, simply start the InEngine Scheduler.  sudo supervisorctl start inengine-scheduler:*", 
            "title": "Starting Supervisor"
        }, 
        {
            "location": "/queuing/", 
            "text": "Queuing\n\n\nPrerequisites\n\n\nRedis is required to use the InEngine.NET Queue feature. \nIt can be installed on Ubuntu with this command:\n\n\nsudo apt-get install redis-server\n\n\n\n\nStart Redis with this command:\n\n\nsudo service redis start\n\n\n\n\n\nIt is highly recommended to \nset a password\n for Redis.\n\n\n\n\nWorking with Queues\n\n\nPublishing Commands\n\n\nProgrammatically\n\n\nCommands\n can be published programmatically with the \nInEngine.Core.Queue.Broker\n class:\n\n\nBroker.Make().Publish(new MyCommand());\n\n\n\n\nFrom the Command Line\n\n\nCommands can be published from the command line as well.\nNote that all queue commands reside in the \nInEngine.Core\n plugin.\nThis is an example of how to publish a command from the CLI by specifying the commands assembly, class name, and arguments:\n\n\nInEngineCli.exe -pInEngine.Core queue:publish --command-assembly=MyCommandPlugin.dll --command-class=MyCommand --args \ntext=bar\n\n\n\n\n\nThere is an \"Echo\" command in the \nInEngine.Core\n package. It is useful for end-to-end testing with the queue feature.\n\n\nInEngineCli.exe -pInEngine.Core queue:publish --command-assembly=InEngine.Core.dll --command-class=InEngine.Core.Commands.Echo --args \ntext=foo\n\n\n\n\n\nConsuming Commands\n\n\nProgrammatically\n\n\nConsuming a command is also accomplished with the Broker class:\n\n\nBroker.Make().Consume();\n\n\n\n\nBoth methods take an optional second argument to indicate if the secondary queue should be used instead of the primary queue.\n\n\n// Uses secondary queue.\nBroker.Make().Consume(true);\n\n\n\n\nCommands can be consumed from the command line as well with this simple command:\n\n\nFrom the Command Line\n\n\nInEngineCli.exe -pInEngine.Core queue:consume\n\n\n\n\nuse the \n--secondary\n switch to consume the secondary queue instead of the primary queue:\n\n\nInEngineCli.exe -pInEngine.Core queue:consume --secondary\n\n\n\n\nWith the Scheduler\n\n\nThe InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of \nways to run the scheduler\n.", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#queuing", 
            "text": "", 
            "title": "Queuing"
        }, 
        {
            "location": "/queuing/#prerequisites", 
            "text": "Redis is required to use the InEngine.NET Queue feature. \nIt can be installed on Ubuntu with this command:  sudo apt-get install redis-server  Start Redis with this command:  sudo service redis start  \nIt is highly recommended to  set a password  for Redis.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/queuing/#working-with-queues", 
            "text": "", 
            "title": "Working with Queues"
        }, 
        {
            "location": "/queuing/#publishing-commands", 
            "text": "", 
            "title": "Publishing Commands"
        }, 
        {
            "location": "/queuing/#programmatically", 
            "text": "Commands  can be published programmatically with the  InEngine.Core.Queue.Broker  class:  Broker.Make().Publish(new MyCommand());", 
            "title": "Programmatically"
        }, 
        {
            "location": "/queuing/#from-the-command-line", 
            "text": "Commands can be published from the command line as well.\nNote that all queue commands reside in the  InEngine.Core  plugin.\nThis is an example of how to publish a command from the CLI by specifying the commands assembly, class name, and arguments:  InEngineCli.exe -pInEngine.Core queue:publish --command-assembly=MyCommandPlugin.dll --command-class=MyCommand --args  text=bar   There is an \"Echo\" command in the  InEngine.Core  package. It is useful for end-to-end testing with the queue feature.  InEngineCli.exe -pInEngine.Core queue:publish --command-assembly=InEngine.Core.dll --command-class=InEngine.Core.Commands.Echo --args  text=foo", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#consuming-commands", 
            "text": "", 
            "title": "Consuming Commands"
        }, 
        {
            "location": "/queuing/#programmatically_1", 
            "text": "Consuming a command is also accomplished with the Broker class:  Broker.Make().Consume();  Both methods take an optional second argument to indicate if the secondary queue should be used instead of the primary queue.  // Uses secondary queue.\nBroker.Make().Consume(true);  Commands can be consumed from the command line as well with this simple command:", 
            "title": "Programmatically"
        }, 
        {
            "location": "/queuing/#from-the-command-line_1", 
            "text": "InEngineCli.exe -pInEngine.Core queue:consume  use the  --secondary  switch to consume the secondary queue instead of the primary queue:  InEngineCli.exe -pInEngine.Core queue:consume --secondary", 
            "title": "From the Command Line"
        }, 
        {
            "location": "/queuing/#with-the-scheduler", 
            "text": "The InEngine scheduler is needed to consume queued messages in the background. \nThere are a variety of  ways to run the scheduler .", 
            "title": "With the Scheduler"
        }
    ]
}